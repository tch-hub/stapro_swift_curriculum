{
	"sections": [
		{
			"id": "layout",
			"title": "レイアウト修飾子",
			"description": "ビューのサイズ、余白、位置を制御する修飾子です。",
			"codeBlocks": [
				{
					"title": "padding() - 余白の設定",
					"code": "// padding()で余白を追加\nText(\"Hello, SwiftUI!\")\n    .padding()                    // 全方向にデフォルト余白（16pt程度）\n\nText(\"Hello, SwiftUI!\")\n    .padding(.horizontal)         // 左右のみ余白\n    .padding(.vertical, 20)       // 上下に20ptの余白\n\nText(\"Hello, SwiftUI!\")\n    .padding(EdgeInsets(          // 個別に指定\n        top: 10,\n        leading: 20,\n        bottom: 10,\n        trailing: 20\n    ))",
					"keywords": ["margin", "space", "inset", "余白", "パディング", "間隔"]
				},
				{
					"title": "EdgeInsets - 4辺の余白を指定",
					"code": "// EdgeInsets()は、ビューの上下左右の余白を個別に指定する構造体\n// 主に padding() や listRowInsets() の引数として使用される\n\n// === 基本的な使い方 ===\n\n// すべてのパラメータを指定\nText(\"カスタム余白\")\n    .padding(EdgeInsets(\n        top: 10,      // 上\n        leading: 20,  // 左（RTL対応）\n        bottom: 10,   // 下\n        trailing: 20  // 右（RTL対応）\n    ))\n\n// === 括弧内を書かない場合 ===\n\n// EdgeInsets()と括弧内を空にすると、すべての値が 0 になる\nText(\"余白なし\")\n    .padding(EdgeInsets())\n    // これは .padding(EdgeInsets(top: 0, leading: 0, bottom: 0, trailing: 0)) と同じ\n    // 結果的に余白がまったく追加されない\n\n// === 部分的にnilを指定する場合 ===\n\n// listRowInsets()では、nilを指定して特定の辺のデフォルト値を保持できる\nList {\n    Text(\"例1\")\n        .listRowInsets(EdgeInsets(\n            top: 0,\n            leading: nil,    // デフォルト値を使用\n            bottom: 0,\n            trailing: 0\n        ))\n}\n\n// === 対称的な余白の指定方法 ===\n\n// すべて同じ値\nText(\"全方向10pt\")\n    .padding(EdgeInsets(top: 10, leading: 10, bottom: 10, trailing: 10))\n    // .padding(10) と同じ結果\n\n// 上下と左右が同じ\nText(\"上下10pt、左右20pt\")\n    .padding(EdgeInsets(top: 10, leading: 20, bottom: 10, trailing: 20))\n\n// === 実践的な例 ===\n\n// リスト行で背景が画面端まで広がる場合\nstruct FullWidthListView: View {\n    var body: some View {\n        List {\n            VStack {\n                HStack {\n                    Image(systemName: \"star.fill\")\n                    Text(\"おすすめ\")\n                }\n            }\n            .padding(.vertical, 12)\n            .background(Color.yellow.opacity(0.2))\n            .listRowInsets(EdgeInsets(\n                top: 0,\n                leading: 0,    // 左の余白なし\n                bottom: 0,\n                trailing: 0    // 右の余白なし\n            ))\n            // このEdgeInsets()により、背景が左右いっぱいに広がる\n        }\n    }\n}\n\n// 特定の辺のみカスタマイズ\nstruct CustomPaddingView: View {\n    var body: some View {\n        VStack {\n            // 上下のみに余白を追加\n            Text(\"テキスト\")\n                .padding(EdgeInsets(\n                    top: 20,\n                    leading: 0,\n                    bottom: 20,\n                    trailing: 0\n                ))\n            \n            // 左右のみに余白を追加\n            Text(\"テキスト\")\n                .padding(EdgeInsets(\n                    top: 0,\n                    leading: 20,\n                    bottom: 0,\n                    trailing: 20\n                ))\n        }\n    }\n}\n\n// === EdgeInsets() と EdgeInsets の違い ===\n\n// EdgeInsets() - 初期化時にすべてのパラメータが 0 になる（引数なし）\nlet emptyInsets = EdgeInsets()\n// top: 0, leading: 0, bottom: 0, trailing: 0\n\n// EdgeInsets(top:, leading:, bottom:, trailing:) - 各値を指定\nlet customInsets = EdgeInsets(top: 10, leading: 20, bottom: 10, trailing: 20)\n\n// === 実装のポイント ===\n\n// 1. padding()で4辺を個別に指定したい場合に使用\n// 2. 括弧内を空にすると、すべての値が 0 になる\n// 3. listRowInsets()では nil を指定してデフォルト値を保持できる\n// 4. leading / trailing は、RTL（右から左）言語にも対応している\n// 5. left / right ではなく leading / trailing を使う（国際化対応）",
					"keywords": [
						"EdgeInsets",
						"insets",
						"padding",
						"margins",
						"top",
						"leading",
						"bottom",
						"trailing",
						"余白",
						"4辺",
						"個別指定"
					]
				},
				{
					"title": "frame() - サイズの指定",
					"code": "// frame()でサイズを指定\nText(\"固定サイズ\")\n    .frame(width: 200, height: 100)     // 幅200pt、高さ100pt\n\nText(\"最小・最大サイズ\")\n    .frame(minWidth: 100, maxWidth: 300)  // 幅の範囲を指定\n\nText(\"親に合わせる\")\n    .frame(maxWidth: .infinity)           // 親の幅いっぱいに広がる\n\nText(\"配置を指定\")\n    .frame(width: 200, height: 100, alignment: .topLeading)  // 左上に配置",
					"keywords": ["size", "width", "height", "dimension", "サイズ", "大きさ", "幅", "高さ"]
				},
				{
					"title": "maxWidth / maxHeight - 最大サイズの制御",
					"code": "// maxWidth()とmaxHeight()は、ビューの最大サイズを制御する修飾子\n// frameと異なり、コンテンツの必要に応じてサイズが縮小される\n\n// === maxWidth() の基本的な使い方 ===\n\n// .infinityで親の幅いっぱいに広がる\nText(\"全幅に広がるテキスト\")\n    .maxWidth(.infinity)\n    .padding()\n    .background(.blue)\n\n// 固定値で最大幅を制限\nText(\"最大300ptまで\")\n    .maxWidth(300)\n    .padding()\n    .background(.green)\n\n// === maxHeight() の使い方 ===\n\n// 縦方向のサイズを制御\nRectangle()\n    .fill(.red)\n    .maxHeight(100)  // 最大高さ100pt\n\n// === 実践的な例 ===\n\n// ボタンを全幅に広げる（モバイルUI パターン）\nstruct FullWidthButton: View {\n    var body: some View {\n        VStack {\n            Button(\"送信\") {\n                // アクション\n            }\n            .buttonStyle(.borderedProminent)\n            .maxWidth(.infinity)  // 親の幅いっぱいに広がる\n            .padding()\n        }\n    }\n}\n\n// テキストフィールドを全幅に広げる\nstruct FullWidthTextField: View {\n    @State private var text = \"\"\n    \n    var body: some View {\n        VStack {\n            TextField(\"入力してください\", text: $text)\n                .textFieldStyle(.roundedBorder)\n                .maxWidth(.infinity)  // 全幅\n                .padding()\n        }\n    }\n}\n\n// HStack内で要素を均等に配置\nstruct EvenDistribution: View {\n    var body: some View {\n        HStack(spacing: 10) {\n            Text(\"左\")\n                .frame(maxWidth: .infinity)\n                .padding()\n                .background(.blue)\n            \n            Text(\"中央\")\n                .frame(maxWidth: .infinity)\n                .padding()\n                .background(.green)\n            \n            Text(\"右\")\n                .frame(maxWidth: .infinity)\n                .padding()\n                .background(.red)\n        }\n        .padding()\n    }\n}\n\n// === frame() との違い ===\n\n// frame(width:) → 幅を確定する（コンテンツがはみ出る可能性もある）\nText(\"固定幅\")\n    .frame(width: 100)  // 100ptで固定\n\n// maxWidth() → 最大幅を制限する（コンテンツに応じて縮小）\nText(\"最大幅\")\n    .maxWidth(100)  // 最大100pt（短いテキストなら小さくなる）\n\n// === アライメント付きの使用方法 ===\n\n// maxWidth + alignment で配置を制御\nVStack {\n    Text(\"左揃え\")\n        .maxWidth(.infinity, alignment: .leading)  // 左端に配置\n    \n    Text(\"中央揃え\")\n        .maxWidth(.infinity, alignment: .center)   // 中央に配置\n    \n    Text(\"右揃え\")\n        .maxWidth(.infinity, alignment: .trailing)  // 右端に配置\n}\n.padding()",
					"keywords": [
						"maxWidth",
						"maxHeight",
						"infinity",
						"expand",
						"fullwidth",
						"最大幅",
						"最大高",
						"拡張"
					]
				},
				{
					"title": "Spacer() - スペースの挿入",
					"code": "// Spacerは利用可能なスペースを埋める\nHStack {\n    Text(\"左\")\n    Spacer()          // 左と右の間を最大限広げる\n    Text(\"右\")\n}\n\nVStack {\n    Text(\"上\")\n    Spacer()\n    Text(\"下\")\n}\n\nHStack {\n    Text(\"左\")\n    Spacer()\n    Text(\"中央\")\n    Spacer()\n    Text(\"右\")        // 均等に配置される\n}",
					"keywords": ["expand", "fill", "space", "スペース", "隙間", "埋める"]
				},
				{
					"title": "spacing - 要素間の間隔",
					"code": "// Stack初期化時に要素間の間隔を指定\nVStack(spacing: 12) {     // 縦方向の間隔を12ptに固定\n    Text(\"要素1\")\n    Text(\"要素2\")\n}\n\nHStack(spacing: 20) {     // 横方向の間隔を20ptに固定\n    Text(\"左\")\n    Text(\"右\")\n}\n\n// spacing: 0 で間隔をなくす\nVStack(spacing: 0) {\n    Text(\"くっついた\")\n    Text(\"テキスト\")\n}",
					"keywords": ["gap", "interval", "margin", "間隔", "スキマ"]
				},
				{
					"title": "alignment - 配置の制御",
					"code": "// VStack, HStack, ZStackの配置\nVStack(alignment: .leading) {     // 左揃え\n    Text(\"短いテキスト\")\n    Text(\"これは長いテキストです\")\n}\n\nHStack(alignment: .top) {         // 上揃え\n    Text(\"高さが\\n異なる\\nテキスト\")\n    Text(\"短い\")\n}\n\nZStack(alignment: .bottomTrailing) {  // 右下に配置\n    Rectangle()\n        .fill(.blue)\n        .frame(width: 200, height: 200)\n    Text(\"右下\")\n}",
					"keywords": ["align", "position", "center", "left", "right", "配置", "揃え", "位置"]
				},
				{
					"title": "offset() - 位置のずらし",
					"code": "// offset()で位置をずらす\nText(\"オフセット\")\n    .offset(x: 20, y: 10)         // 右に20pt、下に10ptずらす\n\n// 重ねて表示する例\nZStack {\n    Circle()\n        .fill(.blue)\n        .frame(width: 100, height: 100)\n    Circle()\n        .fill(.red)\n        .frame(width: 50, height: 50)\n        .offset(x: 30, y: -30)    // 右上にずらす\n}",
					"keywords": ["move", "position", "shift", "ずらす", "移動", "オフセット"]
				},
				{
					"title": "rotationEffect() - 回転",
					"code": "// ビューを回転させる\nText(\"回転テキスト\")\n    .rotationEffect(.degrees(45))  // 時計回りに45度回転\n    .rotationEffect(.radians(.pi)) // ラジアン指定も可能（180度）\n\n// 基準点を指定して回転\nRectangle()\n    .frame(width: 100, height: 50)\n    .rotationEffect(.degrees(90), anchor: .bottomLeading) // 左下を中心に回転\n\n// 3D回転\nText(\"3D回転\")\n    .rotation3DEffect(\n        .degrees(45),\n        axis: (x: 1.0, y: 0.0, z: 0.0) // X軸を中心に回転\n    )",
					"keywords": ["rotate", "angle", "degree", "turn", "3d", "回転", "角度", "回す"]
				},
				{
					"title": "resizable() - 画像のサイズ変更",
					"code": "// 画像をリサイズ可能にする\nImage(systemName: \"star.fill\")\n    .resizable()\n    .frame(width: 50, height: 50)\n\n// アスペクト比を維持して収める（fit）\nImage(\"example\")\n    .resizable()\n    .scaledToFit()     // 枠内に収まるようにリサイズ\n    .frame(width: 200, height: 100)\n    .background(.gray.opacity(0.3))\n\n// アスペクト比を維持して埋める（fill）\nImage(\"example\")\n    .resizable()\n    .scaledToFill()    // 枠を埋めるようにリサイズ\n    .frame(width: 200, height: 100)\n    .clipped()         // はみ出した部分をカット",
					"keywords": [
						"image",
						"scale",
						"aspect",
						"fit",
						"fill",
						"画像",
						"リサイズ",
						"アスペクト比"
					]
				}
			]
		},
		{
			"id": "text",
			"title": "テキストスタイリング",
			"description": "テキストの見た目をカスタマイズする修飾子です。",
			"codeBlocks": [
				{
					"title": "font() - フォントの設定",
					"code": "// システムフォントスタイル\nText(\"Large Title\").font(.largeTitle)   // 34pt\nText(\"Title\").font(.title)               // 28pt\nText(\"Title 2\").font(.title2)            // 22pt\nText(\"Title 3\").font(.title3)            // 20pt\nText(\"Headline\").font(.headline)         // 17pt（太字）\nText(\"Body\").font(.body)                 // 17pt\nText(\"Callout\").font(.callout)           // 16pt\nText(\"Subheadline\").font(.subheadline)   // 15pt\nText(\"Footnote\").font(.footnote)         // 13pt\nText(\"Caption\").font(.caption)           // 12pt\nText(\"Caption 2\").font(.caption2)        // 11pt\n\n// カスタムフォント\nText(\"カスタムサイズ\")\n    .font(.system(size: 24))             // サイズ指定\n\nText(\"デザイン指定\")\n    .font(.system(size: 20, design: .rounded))  // 丸みを帯びたフォント\n\nText(\"モノスペース\")\n    .font(.system(size: 16, design: .monospaced))  // 等幅フォント",
					"keywords": ["type", "size", "style", "フォント", "文字サイズ", "書体"]
				},
				{
					"title": ".system() - カスタムシステムフォント",
					"code": "// .system()でフォントを細かくカスタマイズ\n\n// サイズのみ指定\nText(\"サイズ指定\")\n    .font(.system(size: 24))\n\n// サイズと太さを指定\nText(\"サイズと太さ\")\n    .font(.system(size: 20, weight: .bold))\n\n// サイズ、太さ、デザインをすべて指定\nText(\"フルカスタマイズ\")\n    .font(.system(size: 18, weight: .medium, design: .rounded))\n\n// ===== デザインの種類 =====\n\n// .default - 標準のサンセリフ体\nText(\"Default Design\")\n    .font(.system(size: 20, design: .default))\n\n// .rounded - 丸みを帯びたフォント（フレンドリーな印象）\nText(\"Rounded Design\")\n    .font(.system(size: 20, design: .rounded))\n\n// .monospaced - 等幅フォント（コード表示に最適）\nText(\"Monospaced Design\")\n    .font(.system(size: 20, design: .monospaced))\n\n// .serif - セリフ体（書籍のような印象）\nText(\"Serif Design\")\n    .font(.system(size: 20, design: .serif))\n\n// ===== 実践的な使用例 =====\n\n// 見出しに丸みのあるフォント\nText(\"Welcome!\")\n    .font(.system(size: 32, weight: .bold, design: .rounded))\n\n// コードブロック用の等幅フォント\nText(\"let message = \\\"Hello\\\"\")\n    .font(.system(size: 14, weight: .regular, design: .monospaced))\n    .padding()\n    .background(Color(.secondarySystemBackground))\n    .cornerRadius(8)\n\n// 引用文にセリフ体\nText(\"\\\"The only way to do great work is to love what you do.\\\"\")\n    .font(.system(size: 18, weight: .light, design: .serif))\n    .italic()",
					"keywords": ["custom", "design", "weight", "bold", "カスタム", "太字", "デザイン"]
				},
				{
					"title": "fontWeight() - 太さの設定",
					"code": "// フォントの太さを変更\nText(\"Ultra Light\").fontWeight(.ultraLight)\nText(\"Thin\").fontWeight(.thin)\nText(\"Light\").fontWeight(.light)\nText(\"Regular\").fontWeight(.regular)\nText(\"Medium\").fontWeight(.medium)\nText(\"Semibold\").fontWeight(.semibold)\nText(\"Bold\").fontWeight(.bold)\nText(\"Heavy\").fontWeight(.heavy)\nText(\"Black\").fontWeight(.black)\n\n// 簡易的な太字指定\nText(\"太字テキスト\").bold()",
					"keywords": ["bold", "thin", "heavy", "thickness", "太さ", "ウェイト"]
				},
				{
					"title": "foregroundStyle() - 文字色",
					"code": "// 文字色の設定\nText(\"プライマリ\").foregroundStyle(.primary)       // 標準色\nText(\"セカンダリ\").foregroundStyle(.secondary)     // 薄い色\nText(\"赤色\").foregroundStyle(.red)\nText(\"青色\").foregroundStyle(.blue)\nText(\"アクセント\").foregroundStyle(.accentColor)   // アプリのアクセントカラー\n\n// グラデーション\nText(\"グラデーション\")\n    .foregroundStyle(\n        LinearGradient(\n            colors: [.purple, .pink],\n            startPoint: .leading,\n            endPoint: .trailing\n        )\n    )",
					"keywords": ["color", "text color", "gradient", "文字色", "カラー", "前景色"]
				},
				{
					"title": "foregroundColor() - 文字色（旧API）",
					"code": "// foregroundColor()はビューの前景色（文字色）を設定する修飾子\n// iOS 15以降は foregroundStyle() が推奨されているが、\n// 古いコードや教材ではまだよく見かける\n\n// === 基本的な使い方 ===\n\n// 標準カラーを指定\nText(\"赤色のテキスト\")\n    .foregroundColor(.red)\n\nText(\"青色のテキスト\")\n    .foregroundColor(.blue)\n\n// SF Symbolsの色を変更\nImage(systemName: \"star.fill\")\n    .foregroundColor(.yellow)\n\n// 透明度付きの色\nText(\"半透明のテキスト\")\n    .foregroundColor(.gray.opacity(0.5))\n\n// === foregroundColor() と foregroundStyle() の違い ===\n\n// foregroundColor() - Color型のみ受け取れる\nText(\"色のみ\")\n    .foregroundColor(.blue)          // OK: Color型\n// .foregroundColor(LinearGradient(...))  // エラー: グラデーションは不可\n\n// foregroundStyle() - ShapeStyle全般を受け取れる（Color, Gradient, Material等）\nText(\"色\")\n    .foregroundStyle(.blue)          // OK: Color型\n\nText(\"グラデーション\")\n    .foregroundStyle(                // OK: グラデーションも可能\n        LinearGradient(\n            colors: [.purple, .pink],\n            startPoint: .leading,\n            endPoint: .trailing\n        )\n    )\n\n// foregroundStyle()は複数の階層スタイルも指定可能\nLabel(\"設定\", systemImage: \"gear\")\n    .foregroundStyle(.blue, .gray)   // プライマリ: 青、セカンダリ: グレー\n\n// === 移行のポイント ===\n\n// 旧: foregroundColor（iOS 15で非推奨）\nText(\"旧API\")\n    .foregroundColor(.red)\n\n// 新: foregroundStyle（iOS 15以降推奨）\nText(\"新API\")\n    .foregroundStyle(.red)\n\n// 単純な色指定だけなら、どちらも同じ結果になる\n// 新しいコードでは foregroundStyle() を使うのがベスト",
					"keywords": [
						"foregroundColor",
						"color",
						"text color",
						"deprecated",
						"文字色",
						"前景色",
						"非推奨",
						"旧API"
					]
				},
				{
					"title": "multilineTextAlignment() - 複数行の配置",
					"code": "// 複数行テキストの配置\nText(\"これは長いテキストで\\n複数行にわたります\\n左揃えです\")\n    .multilineTextAlignment(.leading)    // 左揃え\n\nText(\"これは長いテキストで\\n複数行にわたります\\n中央揃えです\")\n    .multilineTextAlignment(.center)     // 中央揃え\n\nText(\"これは長いテキストで\\n複数行にわたります\\n右揃えです\")\n    .multilineTextAlignment(.trailing)   // 右揃え",
					"keywords": ["align", "center", "justify", "行揃え", "配置", "中央揃え", "右揃え"]
				},
				{
					"title": "lineSpacing() / kerning() - 行間・文字間隔",
					"code": "// 行間の設定\nText(\"1行目\\n2行目\\n3行目\")\n    .lineSpacing(10)              // 行間を10pt追加\n\n// 文字間隔の設定\nText(\"文字間隔を広げる\")\n    .kerning(5)                   // 文字間を5pt追加\n\n// 行数制限\nText(\"とても長いテキストがここに入ります。表示しきれない場合は省略されます。\")\n    .lineLimit(2)                 // 最大2行まで表示\n    .truncationMode(.tail)        // 末尾を...で省略",
					"keywords": ["kerning", "interval", "space", "行間", "文字間", "間隔", "文字詰め"]
				},
				{
					"title": "strikethrough() / underline() - 装飾",
					"code": "// 取り消し線\nText(\"取り消し線\")\n    .strikethrough()                       // デフォルトの取り消し線\n\nText(\"赤い取り消し線\")\n    .strikethrough(true, color: .red)      // 色指定\n\n// 下線\nText(\"下線付きテキスト\")\n    .underline()                           // デフォルトの下線\n\nText(\"青い下線\")\n    .underline(true, color: .blue)         // 色指定\n\n// イタリック\nText(\"斜体テキスト\")\n    .italic()",
					"keywords": [
						"underline",
						"decoration",
						"line",
						"装飾",
						"下線",
						"取り消し線",
						"打ち消し線",
						"斜体",
						"イタリック"
					]
				}
			]
		},
		{
			"id": "background-shape",
			"title": "背景と形状",
			"description": "ビューの背景、枠線、形状を設定する修飾子です。",
			"codeBlocks": [
				{
					"title": "background() - 背景の設定",
					"code": "// 色で背景を設定\nText(\"色の背景\")\n    .padding()\n    .background(.blue)\n\n// 透明度付きの背景\nText(\"半透明の背景\")\n    .padding()\n    .background(.blue.opacity(0.3))\n\n// マテリアル（すりガラス効果）\nText(\"マテリアル背景\")\n    .padding()\n    .background(.ultraThinMaterial)    // 薄いすりガラス\n    // .regularMaterial, .thickMaterial なども使用可能\n\n// ビューを背景に\nText(\"画像背景\")\n    .padding()\n    .background {\n        Image(systemName: \"star.fill\")\n            .resizable()\n            .foregroundStyle(.yellow.opacity(0.3))\n    }",
					"keywords": ["color", "fill", "behind", "背景", "背景色", "バックグラウンド"]
				},
				{
					"title": "cornerRadius() / clipShape() - 角丸・形状",
					"code": "// 角丸\nText(\"角丸の背景\")\n    .padding()\n    .background(.blue)\n    .cornerRadius(10)              // 10ptの角丸\n\n// clipShapeで形状にクリップ\nText(\"円形\")\n    .frame(width: 100, height: 100)\n    .background(.blue)\n    .clipShape(Circle())           // 円形にクリップ\n\nText(\"カプセル\")\n    .padding(.horizontal, 20)\n    .padding(.vertical, 10)\n    .background(.green)\n    .clipShape(Capsule())          // カプセル形状\n\nText(\"角丸四角\")\n    .padding()\n    .background(.orange)\n    .clipShape(RoundedRectangle(cornerRadius: 15))  // 角丸四角形",
					"keywords": [
						"rounded",
						"radius",
						"clip",
						"shape",
						"角丸",
						"丸める",
						"クリップ",
						"切り抜き"
					]
				},
				{
					"title": "fill() - 形状の塗りつぶし",
					"code": "// fill()はShape（形状）を色やスタイルで塗りつぶす修飾子\n\n// === 基本的な使い方 ===\n\n// 単色で塗りつぶし\nCircle()\n    .fill(.blue)                       // 青で塗りつぶし\n\nRectangle()\n    .fill(.red)                        // 赤で塗りつぶし\n\nRoundedRectangle(cornerRadius: 10)\n    .fill(.green)                      // 緑で角丸四角を塗りつぶし\n\nCapsule()\n    .fill(.orange)                     // オレンジでカプセルを塗りつぶし\n\nEllipse()\n    .fill(.purple)                     // 紫で楽円を塗りつぶし\n\n// === 透明度付きの塗りつぶし ===\n\nCircle()\n    .fill(.blue.opacity(0.3))          // 半透明の青\n\nRectangle()\n    .fill(.black.opacity(0.5))         // 半透明の黒（オーバーレイなどに）\n\n// === グラデーションで塗りつぶし ===\n\n// 線形グラデーション\nRoundedRectangle(cornerRadius: 15)\n    .fill(\n        LinearGradient(\n            colors: [.blue, .purple],\n            startPoint: .topLeading,\n            endPoint: .bottomTrailing\n        )\n    )\n    .frame(width: 200, height: 100)\n\n// 放射状グラデーション\nCircle()\n    .fill(\n        RadialGradient(\n            colors: [.yellow, .orange],\n            center: .center,\n            startRadius: 0,\n            endRadius: 80\n        )\n    )\n    .frame(width: 160, height: 160)\n\n// === fill() と stroke() の組み合わせ ===\n\n// 塗りつぶし + 枠線（overlayを使う）\nCircle()\n    .fill(.blue)\n    .overlay(\n        Circle()\n            .stroke(.white, lineWidth: 3)\n    )\n    .frame(width: 100, height: 100)\n\n// === fill() と background() の違い ===\n\n// fill() → Shapeに対して使う（Circle, Rectangle など）\nCircle()\n    .fill(.red)          // Shapeを塗りつぶす\n\n// background() → どのViewにも使える（Text, Image など）\nText(\"テキスト\")\n    .background(.red)    // Viewの背景を設定\n\n// Text に fill() は使えない\n// Text(\"テキスト\").fill(.red)  // コンパイルエラー\n\n// === 実践的な使用例 ===\n\n// カード風の背景\nstruct CardView: View {\n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(\"タイトル\").font(.headline)\n            Text(\"説明文がここに入ります\")\n                .foregroundStyle(.secondary)\n        }\n        .padding()\n        .background(\n            RoundedRectangle(cornerRadius: 12)\n                .fill(Color(.secondarySystemBackground))\n        )\n    }\n}\n\n// アイコン背景の円\nstruct IconBadge: View {\n    var body: some View {\n        ZStack {\n            Circle()\n                .fill(.blue.opacity(0.2))\n                .frame(width: 60, height: 60)\n            Image(systemName: \"star.fill\")\n                .foregroundStyle(.blue)\n                .font(.title2)\n        }\n    }\n}",
					"keywords": ["fill", "color", "shape", "gradient", "塗りつぶし", "塗る", "フィル", "形状"]
				},
				{
					"title": "trim() - 形状の切り取り",
					"code": "// 円の一部を表示（半円）\nCircle()\n    .trim(from: 0.0, to: 0.5)      // 0%から50%までを表示\n    .stroke(lineWidth: 10)\n\n// 進捗バーの例\nCircle()\n    .trim(from: 0.0, to: 0.75)     // 75%まで表示\n    .stroke(.blue, style: StrokeStyle(lineWidth: 10, lineCap: .round))\n    .rotationEffect(.degrees(-90)) // 上が0度になるように回転（デフォルトは右が0度）\n\n// 途中から描画\nRectangle()\n    .trim(from: 0.25, to: 0.75)    // 真ん中の50%分を表示\n    .stroke(lineWidth: 5)",
					"keywords": [
						"cut",
						"shape",
						"progress",
						"circle",
						"切り取り",
						"トリム",
						"進捗",
						"プログレス",
						"円グラフ"
					]
				},
				{
					"title": "stroke() - 線の描画",
					"code": "// 形状の輪郭を描画\nCircle()\n    .stroke(Color.blue)            // 青い線\n\n// 線の太さを指定\nRectangle()\n    .stroke(Color.red, lineWidth: 5) // 太さ5ptの赤い線\n\n// スタイルの詳細設定\nCircle()\n    .stroke(\n        Color.green,\n        style: StrokeStyle(\n            lineWidth: 10,\n            lineCap: .round,       // 端の形状（丸）\n            lineJoin: .round,      // 角の形状（丸）\n            dash: [10, 5]          // 点線（10pt線、5pt空白）\n        )\n    )\n\n// 枠線を重ねる（borderの代わり）\nText(\"丸い枠線\")\n    .padding()\n    .overlay(\n        Capsule()\n            .stroke(.orange, lineWidth: 2)\n    )",
					"keywords": ["line", "outline", "border", "shape", "線", "輪郭", "ストローク", "点線"]
				},
				{
					"title": "overlay() - 前面に重ねる",
					"code": "// オーバーレイで前面に要素を重ねる\nImage(systemName: \"photo\")\n    .resizable()\n    .frame(width: 100, height: 100)\n    .overlay(alignment: .bottomTrailing) {\n        Text(\"NEW\")\n            .font(.caption)\n            .padding(4)\n            .background(.red)\n            .foregroundStyle(.white)\n            .cornerRadius(4)\n    }\n\n// 枠線として使用\nText(\"枠線\")\n    .padding()\n    .overlay(\n        RoundedRectangle(cornerRadius: 10)\n            .stroke(.blue, lineWidth: 2)\n    )",
					"keywords": ["front", "top", "stack", "monitor", "重ねる", "オーバーレイ", "前面"]
				},
				{
					"title": "border() - 枠線",
					"code": "// シンプルな枠線\nText(\"枠線付き\")\n    .padding()\n    .border(.blue)                 // 1ptの青い枠線\n\nText(\"太い枠線\")\n    .padding()\n    .border(.red, width: 3)        // 3ptの赤い枠線\n\n// 角丸の枠線はoverlayを使う\nText(\"角丸枠線\")\n    .padding()\n    .overlay(\n        RoundedRectangle(cornerRadius: 10)\n            .stroke(.purple, lineWidth: 2)\n    )",
					"keywords": ["stroke", "outline", "line", "frame", "枠線", "ボーダー", "囲み線"]
				}
			]
		},
		{
			"id": "colors",
			"title": "カラーシステム",
			"description": "SwiftUIのカラー定義とその使い方です。",
			"codeBlocks": [
				{
					"title": "セマンティックカラー",
					"code": "// テキスト用のセマンティックカラー\nText(\"Primary\").foregroundStyle(.primary)       // メインのテキスト色\nText(\"Secondary\").foregroundStyle(.secondary)   // 補助的なテキスト色\nText(\"Tertiary\").foregroundStyle(.tertiary)     // さらに薄いテキスト色\nText(\"Quaternary\").foregroundStyle(.quaternary) // 最も薄いテキスト色\n\n// アクセントカラー\nButton(\"アクセント\") { }\n    .tint(.accentColor)           // アプリのテーマカラー\n\n// ライト/ダークモード対応\n// これらの色は自動的にモードに合わせて変化します",
					"keywords": [
						"theme",
						"mode",
						"dynamic",
						"meaning",
						"semantic",
						"adaptive",
						"primary",
						"secondary",
						"意味的",
						"セマンティック",
						"ダークモード",
						"ライトモード",
						"自動対応",
						"階層"
					]
				},
				{
					"title": "primary - プライマリーカラー",
					"code": "// Color.primaryはシステムが提供する最も目立つテキスト色\n// 標準的なコンテンツの表示に使用\n// ライト/ダークモードに自動対応\n\n// === 基本的な使い方 ===\n\n// テキストの色として使用（通常はデフォルト）\nText(\"メインコンテンツ\")\n    .foregroundStyle(.primary)  // 通常のテキスト色\n\n// 図形の色として使用\nCircle()\n    .fill(Color.primary)\n    .frame(width: 50, height: 50)\n\n// === 実践的な使用例 ===\n\n// タイトルや見出し\nText(\"記事タイトル\")\n    .font(.title)\n    .foregroundStyle(.primary)\n\n// メインのボディテキスト\nText(\"これはメインの本文テキストです。通常の文章に使用します。\")\n    .font(.body)\n    .foregroundStyle(.primary)\n\n// アイコンの色\nImage(systemName: \"house.fill\")\n    .foregroundStyle(.primary)\n\n// 完了/未完了の切り替え\nText(taskTitle)\n    .foregroundStyle(isCompleted ? .secondary : .primary)\n\n// === 実装のポイント ===\n\n// 1. 最も重要な情報に使用（タイトル、本文など）\n// 2. .foregroundStyle()を指定しない場合のデフォルト値\n// 3. ライトモード: ほぼ黒、ダークモード: ほぼ白\n// 4. 最もコントラストが高く、読みやすい色",
					"keywords": [
						"primary",
						"main",
						"text",
						"default",
						"foreground",
						"プライマリー",
						"メイン",
						"主要色",
						"標準",
						"デフォルト",
						"黒",
						"白",
						"本文"
					]
				},
				{
					"title": "accentColor - アクセントカラー",
					"code": "// Color.accentColorはアプリのメインテーマカラー\n// Assets.xcassetsで定義されたAccent Colorが使われる\n// 指定されていない場合は、デフォルトで青色が使用される\n\n// === 基本的な使い方 ===\n\n// テキストや図形の色としての使用\nText(\"アクセントカラー\")\n    .foregroundStyle(Color.accentColor)\n\nCircle()\n    .fill(Color.accentColor)\n    .frame(width: 50, height: 50)\n\n// ボタンの色として使用\nButton(\"ボタン\") { }\n    .buttonStyle(.borderedProminent)\n    .tint(.accentColor)  // または .accentColor を省略可能（デフォルト）\n\n// === 実践的な使用例 ===\n\n// チェックボックスの色（完了状態）\nCircle()\n    .stroke(\n        isCompleted ? Color.accentColor : Color.secondary,\n        lineWidth: 2\n    )\n    .frame(width: 24, height: 24)\n\n// チェックマーク\nImage(systemName: \"checkmark.circle.fill\")\n    .foregroundStyle(Color.accentColor)\n\n// 強調表示したいアイコン\nImage(systemName: \"star.fill\")\n    .foregroundStyle(Color.accentColor)\n    .font(.title)\n\n// プログレスバー\nProgressView(value: 0.7)\n    .tint(Color.accentColor)\n\n// === 実装のポイント ===\n\n// 1. アプリ全体で統一感を出すために使用\n// 2. 重要な操作や選択状態の表示に使用\n// 3. Assets.xcassetsでLight/Dark両方のアクセントカラーを定義可能\n// 4. カスタマイズしない場合はシステムの青色が使われる",
					"keywords": [
						"accentColor",
						"accent",
						"theme",
						"main color",
						"tint",
						"brand",
						"アクセントカラー",
						"テーマカラー",
						"強調色",
						"ブランドカラー",
						"青",
						"選択",
						"完了"
					]
				},
				{
					"title": "secondary - セカンダリーカラー",
					"code": "// Color.secondaryはシステムが提供する補助的な色\n// メインのコンテンツよりも目立たせたくない要素に使用\n// ライト/ダークモードに自動対応\n\n// === 基本的な使い方 ===\n\n// テキストの色として使用（説明文や補足情報など）\nText(\"メインテキスト\")\n    .foregroundStyle(.primary)\nText(\"補足情報\")\n    .foregroundStyle(.secondary)  // 薄いグレー系の色\n\n// 図形の色として使用\nCircle()\n    .fill(Color.secondary)\n    .frame(width: 50, height: 50)\n\n// 枠線の色として使用\nRectangle()\n    .stroke(Color.secondary, lineWidth: 1)\n\n// === 実践的な使用例 ===\n\n// 未完了タスクのチェックボックス\nCircle()\n    .stroke(\n        isCompleted ? Color.accentColor : Color.secondary,\n        lineWidth: 2\n    )\n    .frame(width: 24, height: 24)\n\n// 完了済みタスクのテキスト（薄く表示）\nText(title)\n    .foregroundStyle(isCompleted ? .secondary : .primary)\n    .strikethrough(isCompleted, color: .secondary)\n\n// 説明文やキャプション\nVStack(alignment: .leading) {\n    Text(\"タイトル\")\n        .font(.headline)\n        .foregroundStyle(.primary)\n    Text(\"これは説明文です\")\n        .font(.caption)\n        .foregroundStyle(.secondary)\n}\n\n// アイコンの色（控えめな表示）\nImage(systemName: \"info.circle\")\n    .foregroundStyle(.secondary)\n\n// 区切り線\nDivider()\n    .background(Color.secondary.opacity(0.3))\n\n// プレースホルダーテキスト\nif text.isEmpty {\n    Text(\"入力してください\")\n        .foregroundStyle(.secondary)\n}\n\n// === 実装のポイント ===\n\n// 1. プライマリー情報と区別したい補助的な情報に使用\n// 2. ライト/ダークモードで自動的に見やすい色に調整される\n// 3. ライトモード: 薄いグレー、ダークモード: 明るいグレー\n// 4. アクセシビリティを考慮した読みやすいコントラストを保つ",
					"keywords": [
						"secondary",
						"gray",
						"grey",
						"subtle",
						"muted",
						"caption",
						"セカンダリー",
						"第2",
						"グレー",
						"補助色",
						"薄い色",
						"説明文",
						"キャプション"
					]
				},
				{
					"title": "tertiary - ターシャリーカラー",
					"code": "// Color.tertiaryはセカンダリーよりもさらに薄い色\n// 3番目の重要度の情報に使用\n// ライト/ダークモードに自動対応\n\n// === 基本的な使い方 ===\n\n// テキストの色として使用\nText(\"プライマリー\")\n    .foregroundStyle(.primary)\nText(\"セカンダリー\")\n    .foregroundStyle(.secondary)\nText(\"ターシャリー\")\n    .foregroundStyle(.tertiary)  // さらに薄いグレー\n\n// === 実践的な使用例 ===\n\n// 階層的な情報表示\nVStack(alignment: .leading) {\n    Text(\"タイトル\")\n        .font(.headline)\n        .foregroundStyle(.primary)      // 最も目立つ\n    \n    Text(\"サブタイトル\")\n        .font(.subheadline)\n        .foregroundStyle(.secondary)    // やや控えめ\n    \n    Text(\"補足情報\")\n        .font(.caption)\n        .foregroundStyle(.tertiary)     // 最も控えめ\n}\n\n// プレースホルダーやヒントテキスト\nif items.isEmpty {\n    Text(\"データがありません\")\n        .foregroundStyle(.tertiary)\n        .italic()\n}\n\n// 無効化された要素\nButton(\"無効なボタン\") { }\n    .disabled(true)\n    .foregroundStyle(.tertiary)\n\n// タイムスタンプやメタ情報\nText(\"投稿日: 2025年1月1日\")\n    .font(.caption2)\n    .foregroundStyle(.tertiary)\n\n// === 実装のポイント ===\n\n// 1. 重要度の低い補足情報に使用\n// 2. プレースホルダーや無効状態の表示に最適\n// 3. ライトモード: とても薄いグレー、ダークモード: やや明るいグレー\n// 4. 背景に対して控えめなコントラスト",
					"keywords": [
						"tertiary",
						"third",
						"gray",
						"grey",
						"placeholder",
						"disabled",
						"hint",
						"ターシャリー",
						"第3",
						"3番目",
						"グレー",
						"薄い",
						"プレースホルダー",
						"ヒント",
						"無効",
						"メタ情報"
					]
				},
				{
					"title": "quaternary - クォータナリーカラー",
					"code": "// Color.quaternaryは最も薄いシステムカラー\n// 4番目の重要度の情報に使用\n// ライト/ダークモードに自動対応\n\n// === 基本的な使い方 ===\n\n// テキストの色として使用\nText(\"クォータナリー\")\n    .foregroundStyle(.quaternary)  // 最も薄い色\n\n// === 実践的な使用例 ===\n\n// 4段階の情報階層\nVStack(alignment: .leading, spacing: 4) {\n    Text(\"1. プライマリー情報\")\n        .foregroundStyle(.primary)\n    Text(\"2. セカンダリー情報\")\n        .foregroundStyle(.secondary)\n    Text(\"3. ターシャリー情報\")\n        .foregroundStyle(.tertiary)\n    Text(\"4. クォータナリー情報\")\n        .foregroundStyle(.quaternary)   // 最も控えめ\n}\n\n// 背景パターンや装飾\nRectangle()\n    .fill(Color.quaternary)\n    .frame(height: 1)  // 非常に薄い区切り線\n\n// 透かし文字\nText(\"DRAFT\")\n    .font(.system(size: 60, weight: .bold))\n    .foregroundStyle(.quaternary)\n    .rotationEffect(.degrees(-45))\n    .opacity(0.3)\n\n// 無効化された要素の背景\nText(\"利用不可\")\n    .padding()\n    .background(Color.quaternary.opacity(0.5))\n    .cornerRadius(8)\n\n// === 実装のポイント ===\n\n// 1. 最も目立たせたくない情報に使用\n// 2. 背景パターンや装飾的な要素に最適\n// 3. ライトモード: 非常に薄いグレー、ダークモード: 暗めのグレー\n// 4. 過度に使用すると見えにくくなるため注意",
					"keywords": [
						"quaternary",
						"fourth",
						"lightest",
						"faint",
						"watermark",
						"クォータナリー",
						"第4",
						"4番目",
						"最も薄い",
						"かすかな",
						"透かし",
						"装飾"
					]
				},
				{
					"title": "システム背景色",
					"code": "// UIKitのシステム背景色\n// ライト/ダークモードに自動対応\n\n// === 標準背景色 ===\n\n// .systemBackground - 標準の背景色（最も明るい層）\nVStack {\n    Text(\"メインコンテンツ\")\n}\n.padding()\n.background(Color(.systemBackground))\n\n// .secondarySystemBackground - 2番目の背景色（カードやセル）\nVStack {\n    Text(\"カード\")\n}\n.padding()\n.background(Color(.secondarySystemBackground))\n.cornerRadius(10)\n\n// .tertiarySystemBackground - 3番目の背景色（入れ子の要素）\nVStack {\n    Text(\"入れ子のコンテンツ\")\n}\n.padding()\n.background(Color(.tertiarySystemBackground))\n.cornerRadius(8)\n\n// === グループ化された背景色 ===\n\n// .systemGroupedBackground - グループ化リストの背景\nList {\n    Text(\"項目\")\n}\n.background(Color(.systemGroupedBackground))\n.listStyle(.grouped)\n\n// .secondarySystemGroupedBackground - グループ化リストのセル背景\nVStack {\n    Text(\"セクション\")\n}\n.padding()\n.background(Color(.secondarySystemGroupedBackground))\n\n// .tertiarySystemGroupedBackground - グループ化リストの入れ子背景\nVStack {\n    Text(\"入れ子\")\n}\n.padding()\n.background(Color(.tertiarySystemGroupedBackground))\n\n// === 実践的な使用例 ===\n\n// カード風のデザイン\nVStack {\n    // 背景全体\n    ScrollView {\n        VStack(spacing: 16) {\n            // カード1\n            VStack(alignment: .leading) {\n                Text(\"タイトル\").font(.headline)\n                Text(\"説明文\").font(.caption)\n            }\n            .padding()\n            .frame(maxWidth: .infinity, alignment: .leading)\n            .background(Color(.secondarySystemBackground))\n            .cornerRadius(12)\n            \n            // カード2\n            VStack(alignment: .leading) {\n                Text(\"タイトル\").font(.headline)\n                Text(\"説明文\").font(.caption)\n            }\n            .padding()\n            .frame(maxWidth: .infinity, alignment: .leading)\n            .background(Color(.secondarySystemBackground))\n            .cornerRadius(12)\n        }\n        .padding()\n    }\n    .background(Color(.systemBackground))\n}\n\n// === 実装のポイント ===\n\n// 1. 階層的なUIデザインを作成する際に使用\n// 2. ライト/ダークモードで自動的に適切な色に変化\n// 3. 標準背景色は一般的な画面、グループ背景色は設定画面などに最適\n// 4. Apple標準アプリと同じ見た目を実現できる",
					"keywords": [
						"background",
						"system",
						"grouped",
						"card",
						"layer",
						"container",
						"systemBackground",
						"secondarySystemBackground",
						"tertiarySystemBackground",
						"systemGroupedBackground",
						"secondarySystemGroupedBackground",
						"tertiarySystemGroupedBackground",
						"背景色",
						"システム背景",
						"カード",
						"レイヤー",
						"階層",
						"画面",
						"設定"
					]
				},
				{
					"title": "システムラベル色",
					"code": "// UIKitのシステムラベル色\n// .primary, .secondary等と同様の階層カラー\n// UIColorとして使用する際に明示的に指定\n\n// === 基本的な使い方 ===\n\n// .label - プライマリーラベル色（.primaryと同等）\nText(\"メインラベル\")\n    .foregroundStyle(Color(.label))\n\n// .secondaryLabel - セカンダリーラベル色\nText(\"補助ラベル\")\n    .foregroundStyle(Color(.secondaryLabel))\n\n// .tertiaryLabel - ターシャリーラベル色\nText(\"第3ラベル\")\n    .foregroundStyle(Color(.tertiaryLabel))\n\n// .quaternaryLabel - クォータナリーラベル色\nText(\"第4ラベル\")\n    .foregroundStyle(Color(.quaternaryLabel))\n\n// === 実装のポイント ===\n\n// 1. SwiftUIでは通常 .primary, .secondary などを使う\n// 2. UIKitとの互換性が必要な場合に使用\n// 3. Color(.label) と .primary は同じ色",
					"keywords": [
						"label",
						"secondaryLabel",
						"tertiaryLabel",
						"quaternaryLabel",
						"text",
						"uikit",
						"compatibility",
						"ラベル色",
						"テキスト色",
						"互換性",
						"旧API"
					]
				},
				{
					"title": "システムフィル色",
					"code": "// システムフィル色は半透明の塗りつぶし色\n// ボタンやセルの背景に使用\n// 背景が透けて見えるため、重ねて使うのに適している\n\n// === 基本的な使い方 ===\n\n// .systemFill - 標準フィル色\nButton(\"ボタン\") { }\n    .padding()\n    .background(Color(.systemFill))\n    .cornerRadius(8)\n\n// .secondarySystemFill - セカンダリーフィル色\nButton(\"ボタン\") { }\n    .padding()\n    .background(Color(.secondarySystemFill))\n    .cornerRadius(8)\n\n// .tertiarySystemFill - ターシャリーフィル色\nButton(\"ボタン\") { }\n    .padding()\n    .background(Color(.tertiarySystemFill))\n    .cornerRadius(8)\n\n// .quaternarySystemFill - クォータナリーフィル色（最も薄い）\nButton(\"ボタン\") { }\n    .padding()\n    .background(Color(.quaternarySystemFill))\n    .cornerRadius(8)\n\n// === 実践的な使用例 ===\n\n// タグやバッジ\nText(\"NEW\")\n    .font(.caption)\n    .padding(.horizontal, 8)\n    .padding(.vertical, 4)\n    .background(Color(.secondarySystemFill))\n    .cornerRadius(4)\n\n// ホバー状態のボタン\nButton(\"選択\") { }\n    .padding()\n    .background(isHovered ? Color(.tertiarySystemFill) : Color.clear)\n    .cornerRadius(8)\n\n// === 実装のポイント ===\n\n// 1. 半透明なので背景が透けて見える\n// 2. 階層的なUIに適している\n// 3. ボタンの通常状態やホバー状態に使用\n// 4. ライト/ダークモードで自動調整",
					"keywords": [
						"fill",
						"systemFill",
						"secondarySystemFill",
						"tertiarySystemFill",
						"quaternarySystemFill",
						"button",
						"background",
						"translucent",
						"overlay",
						"badge",
						"tag",
						"フィル",
						"塗りつぶし",
						"半透明",
						"オーバーレイ",
						"バッジ",
						"タグ",
						"ボタン背景"
					]
				},
				{
					"title": "システムグレースケール",
					"code": "// システムグレー色\n// ライト/ダークモードで色が変わらない固定グレー\n// （他のシステムカラーと異なり、モード非対応）\n\n// === グレースケール（薄い順） ===\n\n// .systemGray - 標準グレー\nCircle()\n    .fill(Color(.systemGray))\n    .frame(width: 50, height: 50)\n\n// .systemGray2 - やや薄いグレー\nCircle()\n    .fill(Color(.systemGray2))\n    .frame(width: 50, height: 50)\n\n// .systemGray3 - 中間グレー\nCircle()\n    .fill(Color(.systemGray3))\n    .frame(width: 50, height: 50)\n\n// .systemGray4 - やや明るいグレー\nCircle()\n    .fill(Color(.systemGray4))\n    .frame(width: 50, height: 50)\n\n// .systemGray5 - 明るいグレー\nCircle()\n    .fill(Color(.systemGray5))\n    .frame(width: 50, height: 50)\n\n// .systemGray6 - 最も明るいグレー\nCircle()\n    .fill(Color(.systemGray6))\n    .frame(width: 50, height: 50)\n\n// === 実践的な使用例 ===\n\n// 固定色が必要な場合（デザインの一貫性）\nRectangle()\n    .fill(Color(.systemGray4))\n    .frame(height: 1)  // 常に同じグレーの区切り線\n\n// グレースケールの背景\nVStack {\n    Text(\"コンテンツ\")\n}\n.padding()\n.background(Color(.systemGray6))\n.cornerRadius(10)\n\n// === 実装のポイント ===\n\n// 1. ライト/ダークモードで色が変わらない\n// 2. 番号が大きいほど明るい（.systemGray6が最も明るい）\n// 3. ダークモードでも見た目を統一したい場合に使用\n// 4. 通常は .secondary などのセマンティックカラーを推奨",
					"keywords": [
						"gray",
						"grey",
						"systemGray",
						"systemGray2",
						"systemGray3",
						"systemGray4",
						"systemGray5",
						"systemGray6",
						"fixed",
						"constant",
						"scale",
						"グレー",
						"灰色",
						"固定色",
						"モード非対応",
						"グレースケール",
						"段階"
					]
				},
				{
					"title": "その他のシステムカラー",
					"code": "// その他の便利なシステムカラー\n\n// === .placeholderText - プレースホルダー用テキスト色 ===\n\n// テキストフィールドのプレースホルダー\nif text.isEmpty {\n    Text(\"名前を入力してください\")\n        .foregroundStyle(Color(.placeholderText))\n}\n\n// 空の状態のメッセージ\nif items.isEmpty {\n    VStack {\n        Image(systemName: \"tray\")\n            .font(.largeTitle)\n        Text(\"データがありません\")\n    }\n    .foregroundStyle(Color(.placeholderText))\n}\n\n// === .separator - 区切り線の色 ===\n\n// 標準的な区切り線（半透明）\nRectangle()\n    .fill(Color(.separator))\n    .frame(height: 1)\n\n// リスト内の区切り線\nVStack {\n    Text(\"項目1\")\n    Divider()\n        .background(Color(.separator))\n    Text(\"項目2\")\n}\n\n// === .opaqueSeparator - 不透明な区切り線の色 ===\n\n// 不透明な区切り線\nRectangle()\n    .fill(Color(.opaqueSeparator))\n    .frame(height: 1)\n\n// === .link - リンク用テキスト色 ===\n\n// リンクテキスト\nText(\"利用規約を読む\")\n    .foregroundStyle(Color(.link))\n    .underline()\n\nButton(\"ヘルプを表示\") { }\n    .foregroundStyle(Color(.link))\n\n// === 実践的な使用例 ===\n\n// カスタムテキストフィールド\nstruct CustomTextField: View {\n    @State private var text = \"\"\n    let placeholder: String\n    \n    var body: some View {\n        ZStack(alignment: .leading) {\n            if text.isEmpty {\n                Text(placeholder)\n                    .foregroundStyle(Color(.placeholderText))\n            }\n            TextField(\"\", text: $text)\n        }\n        .padding()\n        .background(Color(.secondarySystemBackground))\n        .cornerRadius(8)\n    }\n}\n\n// セクション区切り\nVStack(spacing: 0) {\n    Text(\"セクション1\")\n        .padding()\n    \n    Rectangle()\n        .fill(Color(.separator))\n        .frame(height: 1)\n    \n    Text(\"セクション2\")\n        .padding()\n}\n\n// === 実装のポイント ===\n\n// 1. .placeholderText - 入力欄のヒントテキストに使用\n// 2. .separator - 半透明の区切り線（ListやDivider）\n// 3. .opaqueSeparator - 不透明な区切り線\n// 4. .link - クリック可能なリンクテキスト（青色）",
					"keywords": [
						"placeholder",
						"placeholderText",
						"separator",
						"opaqueSeparator",
						"link",
						"divider",
						"hint",
						"empty",
						"hyperlink",
						"プレースホルダー",
						"区切り線",
						"リンク",
						"ヒント",
						"空状態",
						"入力欄",
						"ハイパーリンク"
					]
				},
				{
					"title": "システムカラー（旧API）",
					"code": "// UIKitのシステムカラーを使用\n// これらは Color(.systemBackground) のように UIColor として使用\n// SwiftUIの .primary, .secondary などを使う方が推奨される\n\n// === 背景色 ===\nText(\"システム背景\")\n    .padding()\n    .background(Color(.systemBackground))         // 背景色\n\nText(\"セカンダリ背景\")\n    .padding()\n    .background(Color(.secondarySystemBackground))  // 二次背景色\n\nText(\"グループ背景\")\n    .padding()\n    .background(Color(.systemGroupedBackground))   // グループ背景色\n\n// === グレースケール ===\nText(\"グレー\").foregroundStyle(Color(.systemGray))\nText(\"グレー2\").foregroundStyle(Color(.systemGray2))\nText(\"グレー3\").foregroundStyle(Color(.systemGray3))\nText(\"グレー4\").foregroundStyle(Color(.systemGray4))\nText(\"グレー5\").foregroundStyle(Color(.systemGray5))\nText(\"グレー6\").foregroundStyle(Color(.systemGray6))\n\n// === 注意点 ===\n// SwiftUIでは以下を推奨：\n// - Color(.systemBackground) より .background を使用\n// - Color(.label) より .primary を使用\n// - Color(.systemGray) より .secondary を使用",
					"keywords": [
						"uikit",
						"background",
						"systemBackground",
						"secondarySystemBackground",
						"systemGroupedBackground",
						"gray",
						"grey",
						"systemGray",
						"systemGray2",
						"systemGray3",
						"systemGray4",
						"systemGray5",
						"systemGray6",
						"system",
						"legacy",
						"deprecated",
						"システム",
						"背景",
						"旧API",
						"互換性",
						"非推奨"
					]
				},
				{
					"title": "標準カラー",
					"code": "// SwiftUIの標準カラー\nText(\"Red\").foregroundStyle(.red)\nText(\"Orange\").foregroundStyle(.orange)\nText(\"Yellow\").foregroundStyle(.yellow)\nText(\"Green\").foregroundStyle(.green)\nText(\"Mint\").foregroundStyle(.mint)\nText(\"Teal\").foregroundStyle(.teal)\nText(\"Cyan\").foregroundStyle(.cyan)\nText(\"Blue\").foregroundStyle(.blue)\nText(\"Indigo\").foregroundStyle(.indigo)\nText(\"Purple\").foregroundStyle(.purple)\nText(\"Pink\").foregroundStyle(.pink)\nText(\"Brown\").foregroundStyle(.brown)\nText(\"White\").foregroundStyle(.white)\nText(\"Black\").foregroundStyle(.black)\nText(\"Gray\").foregroundStyle(.gray)\nText(\"Clear\").foregroundStyle(.clear)    // 透明",
					"keywords": [
						"preset",
						"basic",
						"white",
						"black",
						"red",
						"blue",
						"green",
						"yellow",
						"orange",
						"purple",
						"pink",
						"標準",
						"色",
						"カラー",
						"基本色",
						"赤",
						"青",
						"緑",
						"黄",
						"オレンジ",
						"紫",
						"ピンク",
						"白",
						"黒",
						"透明"
					]
				},
				{
					"title": "グラデーション",
					"code": "// 線形グラデーション\nRectangle()\n    .fill(\n        LinearGradient(\n            colors: [.blue, .purple],\n            startPoint: .topLeading,\n            endPoint: .bottomTrailing\n        )\n    )\n    .frame(height: 100)\n\n// 放射状グラデーション\nCircle()\n    .fill(\n        RadialGradient(\n            colors: [.yellow, .orange, .red],\n            center: .center,\n            startRadius: 0,\n            endRadius: 100\n        )\n    )\n    .frame(width: 200, height: 200)\n\n// 角度グラデーション\nCircle()\n    .fill(\n        AngularGradient(\n            colors: [.red, .yellow, .green, .blue, .purple, .red],\n            center: .center\n        )\n    )\n    .frame(width: 200, height: 200)",
					"keywords": [
						"linear",
						"radial",
						"angular",
						"color",
						"gradient",
						"effect",
						"グラデーション",
						"線形",
						"円形",
						"放射状",
						"角度",
						"グラデ",
						"色の変化"
					]
				},
				{
					"title": "カスタムカラー",
					"code": "// RGB値で色を作成\nlet customRed = Color(red: 1.0, green: 0.2, blue: 0.2)\n\n// 16進数から色を作成\nlet hexColor = Color(red: 0x3A / 255, green: 0x86 / 255, blue: 0xFF / 255)\n\n// 透明度を設定\nlet semiTransparent = Color.blue.opacity(0.5)\n\n// Assets.xcassets でカラーセットを定義した場合\n// let assetColor = Color(\"MyCustomColor\")",
					"keywords": [
						"rgb",
						"hex",
						"assets",
						"color set",
						"opacity",
						"alpha",
						"custom",
						"カスタム",
						"自作",
						"16進数",
						"透明度",
						"アセット",
						"カラーセット",
						"オリジナル"
					]
				}
			]
		},
		{
			"id": "animation",
			"title": "アニメーション",
			"description": "ビューの変化をアニメーションさせる方法です。",
			"codeBlocks": [
				{
					"title": "animation() - アニメーション修飾子",
					"code": "// 状態変化をアニメーション\nstruct AnimationExample: View {\n    @State private var isExpanded = false\n\n    var body: some View {\n        VStack {\n            Rectangle()\n                .fill(.blue)\n                .frame(width: isExpanded ? 200 : 100,\n                       height: isExpanded ? 200 : 100)\n                .animation(.default, value: isExpanded)  // デフォルトアニメーション\n\n            Button(\"トグル\") {\n                isExpanded.toggle()\n            }\n        }\n    }\n}",
					"keywords": ["motion", "effect", "transition", "state", "動き", "アニメーション"]
				},
				{
					"title": "withAnimation - アニメーションブロック",
					"code": "// withAnimationで明示的にアニメーション\nstruct WithAnimationExample: View {\n    @State private var scale = 1.0\n\n    var body: some View {\n        VStack {\n            Circle()\n                .fill(.purple)\n                .frame(width: 100, height: 100)\n                .scaleEffect(scale)\n\n            Button(\"アニメーション\") {\n                withAnimation(.spring(response: 0.3, dampingFraction: 0.5)) {\n                    scale = scale == 1.0 ? 1.5 : 1.0\n                }\n            }\n        }\n    }\n}",
					"keywords": ["explicit", "block", "trigger", "logic", "明示的", "ブロック"]
				},
				{
					"title": "アニメーションの種類",
					"code": "// 様々なアニメーションカーブ\n.animation(.linear, value: state)              // 一定速度\n.animation(.easeIn, value: state)              // ゆっくり始まる\n.animation(.easeOut, value: state)             // ゆっくり終わる\n.animation(.easeInOut, value: state)           // 両端がゆっくり\n\n// スプリングアニメーション\n.animation(.spring(), value: state)            // デフォルトのバネ\n.animation(.spring(response: 0.3, dampingFraction: 0.5), value: state)  // カスタマイズ\n.animation(.bouncy, value: state)              // 弾むような動き\n\n// 速度とリピート\n.animation(.linear(duration: 2), value: state)                // 2秒かける\n.animation(.easeInOut.repeatForever(), value: state)          // 永遠に繰り返し\n.animation(.easeInOut.repeatCount(3, autoreverses: true), value: state)  // 3回繰り返し",
					"keywords": ["spring", "linear", "ease", "curve", "カーブ", "速度", "イージング", "バネ"]
				},
				{
					"title": "transition() - 表示/非表示のトランジション",
					"code": "// 表示・非表示時のアニメーション\nstruct TransitionExample: View {\n    @State private var showDetail = false\n\n    var body: some View {\n        VStack {\n            Button(\"トグル\") {\n                withAnimation {\n                    showDetail.toggle()\n                }\n            }\n\n            if showDetail {\n                Text(\"詳細テキスト\")\n                    .transition(.slide)         // スライドで表示/非表示\n            }\n        }\n    }\n}\n\n// トランジションの種類\n.transition(.opacity)                          // フェード\n.transition(.scale)                            // 拡大/縮小\n.transition(.slide)                            // スライド\n.transition(.move(edge: .top))                 // 上から出入り\n.transition(.push(from: .bottom))              // 下からプッシュ\n\n// 組み合わせ\n.transition(.scale.combined(with: .opacity))   // 複数を組み合わせ\n.transition(.asymmetric(                       // 表示と非表示で異なる\n    insertion: .scale,\n    removal: .opacity\n))",
					"keywords": [
						"appear",
						"disappear",
						"show",
						"hide",
						"example",
						"遷移",
						"トランジション",
						"表示",
						"非表示"
					]
				},
				{
					"title": "アニメーション可能なプロパティ",
					"code": "// アニメーション可能な修飾子\n.opacity(0.5)                    // 透明度\n.scaleEffect(1.5)                // 拡大縮小\n.rotationEffect(.degrees(45))    // 回転\n.offset(x: 50, y: 50)            // 位置移動\n.frame(width: 200, height: 200)  // サイズ変更\n\n// 実践例\nstruct PracticalAnimation: View {\n    @State private var isAnimating = false\n\n    var body: some View {\n        Image(systemName: \"heart.fill\")\n            .font(.system(size: 50))\n            .foregroundStyle(.red)\n            .scaleEffect(isAnimating ? 1.2 : 1.0)\n            .opacity(isAnimating ? 1.0 : 0.5)\n            .animation(\n                .easeInOut(duration: 0.5).repeatForever(autoreverses: true),\n                value: isAnimating\n            )\n            .onAppear {\n                isAnimating = true\n            }\n    }\n}",
					"keywords": ["animatable", "values", "change", "プロパティ", "変化", "拡大", "回転"]
				},
				{
					"title": "spring() - スプリングアニメーション",
					"code": "// spring()は自然な弾む動きのアニメーションを作成\n// response（応答時間）とdampingFraction（減衰率）で動きを制御\n\n// === 基本的な使用方法 ===\n\n// デフォルトのスプリングアニメーション\nstruct SpringExample: View {\n    @State private var isExpanded = false\n\n    var body: some View {\n        VStack {\n            Circle()\n                .fill(.blue)\n                .frame(width: isExpanded ? 200 : 100,\n                       height: isExpanded ? 200 : 100)\n                .animation(.spring(), value: isExpanded)  // デフォルト\n\n            Button(\"トグル\") {\n                isExpanded.toggle()\n            }\n        }\n    }\n}\n\n// === パラメータの詳細 ===\n\n// response - 応答時間（秒）。値が小さいほど速く反応\n.animation(.spring(response: 0.3), value: state)   // 0.3秒で反応（速い）\n.animation(.spring(response: 1.0), value: state)   // 1.0秒で反応（遅い）\n\n// dampingFraction - 減衰率（0～1）。値が小さいほど弾む\n.animation(.spring(dampingFraction: 0.3), value: state)  // 弾む動き\n.animation(.spring(dampingFraction: 0.7), value: state)  // 控えめな動き\n.animation(.spring(dampingFraction: 1.0), value: state)  // 弾まない（クリティカル）\n\n// === 実践的な組み合わせ ===\n\n// 速く弾む動き（カート追加、いいね！など）\n.animation(\n    .spring(response: 0.3, dampingFraction: 0.5),\n    value: isLiked\n)\n\n// ゆっくり弾む動き（画面遷移など）\n.animation(\n    .spring(response: 0.8, dampingFraction: 0.7),\n    value: showDetail\n)\n\n// 滑らかな動き（通常のUI更新）\n.animation(\n    .spring(response: 0.6, dampingFraction: 1.0),  // dampingFractionが1.0時は弾まない\n    value: selectedTab\n)\n\n// === 実践例 ===\n\n// いいねボタンのアニメーション\nstruct LikeButton: View {\n    @State private var isLiked = false\n\n    var body: some View {\n        VStack {\n            Image(systemName: isLiked ? \"heart.fill\" : \"heart\")\n                .font(.system(size: 48))\n                .foregroundStyle(isLiked ? .red : .gray)\n                .scaleEffect(isLiked ? 1.3 : 1.0)\n                .animation(\n                    .spring(response: 0.4, dampingFraction: 0.6),\n                    value: isLiked\n                )\n\n            Button(action: { isLiked.toggle() }) {\n                Text(isLiked ? \"いいね取消\" : \"いいね！\")\n            }\n            .buttonStyle(.borderedProminent)\n        }\n        .padding()\n    }\n}\n\n// ポップアップのアニメーション\nstruct PopupAnimation: View {\n    @State private var showPopup = false\n\n    var body: some View {\n        ZStack {\n            VStack {\n                Button(\"ポップアップ表示\") {\n                    withAnimation(.spring(response: 0.5, dampingFraction: 0.7)) {\n                        showPopup = true\n                    }\n                }\n            }\n\n            if showPopup {\n                VStack {\n                    Text(\"成功！\")\n                        .font(.headline)\n                    Text(\"データが保存されました\")\n                        .font(.caption)\n                        .foregroundStyle(.secondary)\n                }\n                .padding()\n                .background(.green.opacity(0.9))\n                .foregroundStyle(.white)\n                .cornerRadius(12)\n                .scaleEffect(showPopup ? 1.0 : 0.1)\n                .opacity(showPopup ? 1.0 : 0.0)\n                .animation(.spring(response: 0.5, dampingFraction: 0.7), value: showPopup)\n                .transition(.scale.combined(with: .opacity))\n            }\n        }\n        .padding()\n    }\n}",
					"keywords": ["spring", "bounce", "response", "damping", "弾む", "スプリング", "バウンス"]
				},
				{
					"title": "contentTransition() - コンテンツ変更のアニメーション",
					"code": "// contentTransition()は、ビューのコンテンツが変更されるときのアニメーション\n// iOS 17以降で利用可能\n\n// 数値テキストの変更をスムーズにアニメーション\nstruct CounterWithTransition: View {\n    @State private var count = 0\n\n    var body: some View {\n        VStack {\n            Text(\"\\(count)\")\n                .font(.title)\n                .contentTransition(.numericText())  // 数値の変更をアニメーション化\n\n            Button(\"増加\") {\n                withAnimation {\n                    count += 1\n                }\n            }\n        }\n    }\n}\n\n// === contentTransitionの種類 ===\n\n// .identity - トランジション無し（デフォルト）\nText(message)\n    .contentTransition(.identity)\n\n// .numericText() - 数値テキストの変更時にスムーズに増減\nText(\"スコア: \\(score)\")\n    .contentTransition(.numericText())\n\n// .numericText(countsDown:) - カウントダウン表示用（逆方向）\nText(\"残り: \\(seconds)秒\")\n    .contentTransition(.numericText(countsDown: true))\n\n// .opacity - フェード出入り\nText(dynamicText)\n    .contentTransition(.opacity)\n\n// === 実践例 ===\n\n// スコアアップアニメーション\nstruct ScoreAnimation: View {\n    @State private var score = 1000\n\n    var body: some View {\n        VStack {\n            Text(\"スコア\")\n                .font(.caption)\n                .foregroundStyle(.secondary)\n\n            Text(\"\\(score)\")\n                .font(.system(size: 48, weight: .bold, design: .default))\n                .contentTransition(.numericText())\n                .animation(.easeInOut(duration: 0.5), value: score)\n\n            Button(\"+100ポイント\") {\n                score += 100\n            }\n            .buttonStyle(.borderedProminent)\n        }\n        .padding()\n    }\n}\n\n// タイマーのカウントダウン\nstruct TimerView: View {\n    @State private var timeRemaining = 60\n\n    var body: some View {\n        Text(\"\\(timeRemaining)秒\")\n            .font(.title2)\n            .contentTransition(.numericText(countsDown: true))\n            .animation(.linear(duration: 1), value: timeRemaining)\n            .onAppear {\n                Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in\n                    if timeRemaining > 0 {\n                        timeRemaining -= 1\n                    }\n                }\n            }\n    }\n}",
					"keywords": [
						"numeric",
						"text",
						"content",
						"counter",
						"score",
						"数値",
						"カウンター",
						"スコア"
					]
				}
			]
		},
		{
			"id": "interactive",
			"title": "インタラクティブスタイル",
			"description": "ボタン、リスト、テキストフィールドなどのスタイルを設定する修飾子です。",
			"codeBlocks": [
				{
					"title": "buttonStyle() - ボタンスタイル",
					"code": "// ボタンスタイルの種類\nButton(\"Default\") { }\n    // デフォルトスタイル（指定なし）\n\nButton(\"Plain\") { }\n    .buttonStyle(.plain)              // 装飾なし、テキストのみ\n\nButton(\"Bordered\") { }\n    .buttonStyle(.bordered)           // 枠線付き\n\nButton(\"Bordered Prominent\") { }\n    .buttonStyle(.borderedProminent)  // 塗りつぶし（目立つ）\n\nButton(\"Borderless\") { }\n    .buttonStyle(.borderless)         // 枠線なし\n\n// tintでボタンの色を変更\nButton(\"カスタム色\") { }\n    .buttonStyle(.borderedProminent)\n    .tint(.green)                     // 緑色のボタン\n\n// controlSizeでサイズを変更\nButton(\"小さいボタン\") { }\n    .buttonStyle(.bordered)\n    .controlSize(.small)              // .mini, .small, .regular, .large\n\nButton(\"大きいボタン\") { }\n    .buttonStyle(.bordered)\n    .controlSize(.large)",
					"keywords": ["border", "plain", "shape", "appearance", "見た目", "ボタンスタイル"]
				},
				{
					"title": "カスタムButtonStyle",
					"code": "// カスタムボタンスタイルの作成\nstruct CustomButtonStyle: ButtonStyle {\n    func makeBody(configuration: Configuration) -> some View {\n        configuration.label\n            .padding(.horizontal, 20)\n            .padding(.vertical, 12)\n            .background(\n                configuration.isPressed ? Color.blue.opacity(0.7) : Color.blue\n            )\n            .foregroundStyle(.white)\n            .cornerRadius(10)\n            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)\n            .animation(.easeInOut(duration: 0.1), value: configuration.isPressed)\n    }\n}\n\n// 使用例\nButton(\"カスタムボタン\") {\n    print(\"タップされました\")\n}\n.buttonStyle(CustomButtonStyle())",
					"keywords": ["configuration", "makeBody", "create", "自作", "カスタム"]
				},
				{
					"title": "listStyle() - リストスタイル",
					"code": "// リストスタイルの種類\nList {\n    Text(\"項目1\")\n    Text(\"項目2\")\n    Text(\"項目3\")\n}\n.listStyle(.automatic)            // 自動（プラットフォームに応じて）\n\nList { ... }\n.listStyle(.plain)                // シンプル、区切り線のみ\n\nList { ... }\n.listStyle(.inset)                // インセット付き\n\nList { ... }\n.listStyle(.insetGrouped)         // グループ化+インセット（設定画面風）\n\nList { ... }\n.listStyle(.grouped)              // グループ化\n\nList { ... }\n.listStyle(.sidebar)              // サイドバー用\n\n// リスト行の背景を変更\nList {\n    Text(\"カスタム背景\")\n        .listRowBackground(Color.yellow.opacity(0.3))\n}\n\n// リスト行の区切り線を非表示\nList {\n    Text(\"区切り線なし\")\n        .listRowSeparator(.hidden)",
					"keywords": ["appearance", "grouped", "sidebar", "inset", "リストスタイル", "見た目"]
				},
				{
					"title": "listRowInsets() - リスト行の余白調整",
					"code": "// listRowInsets()はリスト行の左右の余白（インセット）を調整する修飾子\n// EdgeInsets(top, leading, bottom, trailing)で各辺の余白を指定\n\n// === 基本的な使用方法 ===\n\n// デフォルトのインセット\nList {\n    Text(\"デフォルト\")\n    Text(\"間隔あり\")\n}\n\n// 左右のインセットなし（画面端まで広がる）\nList {\n    Text(\"左右の余白なし\")\n        .listRowInsets(EdgeInsets(top: 0, leading: 0, bottom: 0, trailing: 0))\n}\n\n// 右側のインセットのみ0（左側は標準）\nList {\n    Text(\"右側の余白なし\")\n        .listRowInsets(EdgeInsets(top: 0, leading: nil, bottom: 0, trailing: 0))\n}\n\n// === 実践的な例 ===\n\n// 背景色が画面端まで広がる行\nstruct FullWidthListView: View {\n    var body: some View {\n        List {\n            Text(\"通常の行\")\n            \n            // このセクションだけ背景が端まで広がる\n            VStack {\n                HStack {\n                    Image(systemName: \"star.fill\")\n                        .foregroundStyle(.yellow)\n                    Text(\"おすすめ\")\n                        .font(.headline)\n                }\n            }\n            .frame(maxWidth: .infinity, alignment: .leading)\n            .padding(.vertical, 12)\n            .background(Color.yellow.opacity(0.2))\n            .listRowInsets(EdgeInsets(top: 0, leading: 0, bottom: 0, trailing: 0))\n            // インセットなしで背景が左右いっぱいに広がる\n            \n            Text(\"通常の行\")\n        }\n    }\n}\n\n// キャンペーン画像を全幅で表示\nstruct AdvertisementListView: View {\n    var body: some View {\n        List {\n            Text(\"その他の商品\")\n            \n            Image(systemName: \"photo\")\n                .resizable()\n                .frame(height: 200)\n                .scaledToFill()\n                .listRowInsets(EdgeInsets(top: 8, leading: 0, bottom: 8, trailing: 0))\n                // 左右の余白をなくして画像を全幅に表示\n            \n            Text(\"商品説明\")\n        }\n    }\n}\n\n// === nil パラメータの意味 ===\n\n// leading = nil の場合、デフォルトの左余白を保持\n// trailing = nil の場合、デフォルトの右余白を保持\nList {\n    Text(\"左余白のみデフォルト\")\n        .listRowInsets(EdgeInsets(top: 0, leading: nil, bottom: 0, trailing: 0))\n    \n    Text(\"右余白のみデフォルト\")\n        .listRowInsets(EdgeInsets(top: 0, leading: 0, bottom: 0, trailing: nil))\n}",
					"keywords": [
						"insets",
						"padding",
						"spacing",
						"margin",
						"fullwidth",
						"行の余白",
						"インセット",
						"左右の間隔"
					]
				},
				{
					"title": "listRowSeparator() - リスト行の区切り線",
					"code": "// listRowSeparator()はリスト行の区切り線の表示/非表示を制御する修飾子\n// iOS 15以降で利用可能\n\n// === 基本的な使用方法 ===\n\n// デフォルト（区切り線表示）\nList {\n    Text(\"項目1\")\n    Text(\"項目2\")\n    Text(\"項目3\")\n}\n\n// 区切り線を非表示\nList {\n    Text(\"区切り線なし1\")\n    Text(\"区切り線なし2\")\n    Text(\"区切り線なし3\")\n}\n.listRowSeparator(.hidden)            // すべての行の区切り線を非表示\n\n// === 部分的に区切り線を制御 ===\n\n// 特定の行のみ区切り線を非表示\nList {\n    Text(\"最初の項目\")\n    \n    Text(\"区切り線なし\")\n        .listRowSeparator(.hidden)    // この行だけ区切り線なし\n    \n    Text(\"最後の項目\")\n}\n\n// 複数の行を非表示\nList {\n    ForEach(0..<10, id: \\.self) { index in\n        Text(\"項目 \\(index + 1)\")\n            .listRowSeparator(index == 9 ? .hidden : .visible)  // 最後の行のみ非表示\n    }\n}\n\n// === 区切り線の色とインセットを変更 ===\n\n// iOS 16以降で区切り線のカスタマイズも可能\nList {\n    Text(\"項目1\")\n    Text(\"項目2\")\n}\n.listRowSeparator(.visible, edges: .bottom)  // 下線のみ表示\n\n// === 実践的な例 ===\n\n// セクション分けされたリスト\nstruct SectionedListView: View {\n    var body: some View {\n        List {\n            Section(header: Text(\"設定\")) {\n                Text(\"アカウント\")\n                Text(\"通知\")\n                Text(\"プライバシー\")\n            }\n            \n            Section(header: Text(\"サポート\")) {\n                Text(\"よくある質問\")\n                Text(\"お問い合わせ\")\n                Text(\"利用規約\")\n                    .listRowSeparator(.hidden)  // 最後の行は区切り線なし\n            }\n        }\n    }\n}\n\n// グループ化リストで区切り線を非表示\nList {\n    Text(\"カード1\")\n    Text(\"カード2\")\n    Text(\"カード3\")\n}\n.listStyle(.grouped)\n.listRowSeparator(.hidden)            // グループ化リストのすべての区切り線を非表示\n\n// カスタムセパレータ挿入\nstruct CustomSeparatorListView: View {\n    let items = [\"A\", \"B\", \"C\", \"D\"]\n    \n    var body: some View {\n        List(items, id: \\.self) { item in\n            VStack {\n                Text(item)\n                    .font(.headline)\n                \n                // 区切り線を非表示にして、カスタムセパレータを手動で追加\n                Divider()\n                    .foregroundStyle(.blue)\n            }\n            .listRowSeparator(.hidden)  // デフォルトの区切り線を非表示\n        }\n    }\n}\n\n// === 区切り線の表示/非表示の判定 ===\n\nList {\n    ForEach(Array(items.enumerated()), id: \\.element) { index, item in\n        Text(item)\n            // 最後の項目以外に区切り線を表示\n            .listRowSeparator(\n                index < items.count - 1 ? .visible : .hidden\n            )\n    }\n}\n\n// === 実装のポイント ===\n\n// 1. List全体に適用すると、すべての行に反映される\n// 2. 特定の行に適用して、その行のみを制御できる\n// 3. セクション化されたリストでも行単位で制御可能\n// 4. .visible と .hidden で明示的に制御\n// 5. 区切り線なしの場合、visually separatedされないため注意が必要",
					"keywords": [
						"separator",
						"divider",
						"line",
						"hidden",
						"visible",
						"区切り線",
						"セパレータ",
						"行区切り"
					]
				},
				{
					"title": "textFieldStyle() - テキストフィールドスタイル",
					"code": "// テキストフィールドスタイルの種類\n@State private var text = \"\"\n\nTextField(\"プレースホルダー\", text: $text)\n    // デフォルトスタイル（指定なし）\n\nTextField(\"Plain\", text: $text)\n    .textFieldStyle(.plain)           // 枠線なし\n\nTextField(\"Rounded Border\", text: $text)\n    .textFieldStyle(.roundedBorder)   // 角丸の枠線\n\n// テキストフィールドのカスタマイズ\nTextField(\"カスタム\", text: $text)\n    .padding()\n    .background(Color(.secondarySystemBackground))\n    .cornerRadius(10)\n    .overlay(\n        RoundedRectangle(cornerRadius: 10)\n            .stroke(Color.blue, lineWidth: 1)\n    )",
					"keywords": ["appearance", "border", "input", "field", "入力欄", "テキストフィールド"]
				},
				{
					"title": "axis - テキストフィールドの展開方向",
					"code": "// axis パラメータはTextFieldが複数行になった場合の展開方向を制御する\n// iOS 16以降で利用可能\n\n// === 基本的な使い方 ===\n\n@State private var text = \"\"\n\n// デフォルト（単行）\nTextField(\"1行のみ\", text: $text)\n\n// === axis: .vertical（縦方向展開） ===\n\n// 複数行になると上下方向に拡張される\nTextField(\"説明を入力\", text: $text, axis: .vertical)\n    .padding()\n\n// === axis: .horizontal（横方向展開）===\n\n// 複数行になると左右方向に拡張される（テキストが折り返される）\nTextField(\"横方向\", text: $text, axis: .horizontal)\n\n// === 実践的な例 ===\n\n// チャットアプリのメッセージ入力\nstruct MessageInputView: View {\n    @State private var message = \"\"\n    \n    var body: some View {\n        HStack(alignment: .bottom, spacing: 12) {\n            // 複数行対応の入力欄\n            TextField(\"メッセージを入力...\", text: $message, axis: .vertical)\n                .padding(.vertical, 10)\n                .padding(.horizontal, 16)\n                .background(\n                    Capsule()\n                        .fill(Color(.secondarySystemBackground))\n                )\n                .lineLimit(3...8)  // 最小3行、最大8行\n            \n            Button(action: sendMessage) {\n                Image(systemName: \"arrow.up.circle.fill\")\n                    .font(.system(size: 32))\n            }\n        }\n        .padding()\n    }\n    \n    private func sendMessage() {\n        // 送信処理\n    }\n}\n\n// タスク説明の入力\nstruct TaskDescriptionView: View {\n    @State private var description = \"\"\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(\"タスクの説明\")\n                .font(.headline)\n            \n            TextField(\"詳細を入力してください\", text: $description, axis: .vertical)\n                .padding()\n                .background(Color(.secondarySystemBackground))\n                .cornerRadius(8)\n                .lineLimit(3...5)  // 複数行に対応\n        }\n    }\n}\n\n// === axis と lineLimit の組み合わせ ===\n\n// 最小行数を設定（常に複数行になる）\nTextField(\"最小3行\", text: $text, axis: .vertical)\n    .lineLimit(3...)           // 最小3行\n    .padding()\n\n// 最大行数を制限\nTextField(\"最大5行\", text: $text, axis: .vertical)\n    .lineLimit(1...5)          // 1～5行\n    .padding()\n\n// === axis の違い ===\n\n// axis: .vertical（推奨）\n// - テキストが複数行になると、フィールドの高さが自動で拡張される\n// - チャットやメッセージ入力に最適\nTextField(\"複数行入力\", text: $text, axis: .vertical)\n\n// axis: .horizontal\n// - テキストが折り返され、フィールドの幅内に収まる\n// - 従来のテキストフィールドの動作\nTextField(\"単行\", text: $text, axis: .horizontal)\n\n// === 実装のポイント ===\n\n// 1. axis: .vertical で複数行入力に対応\n// 2. axis: .horizontal は従来のテキストフィールド動作\n// 3. lineLimit() と組み合わせて行数を制限できる\n// 4. .vertical + lineLimit(3...) で最小3行、上限なしの入力欄を実現\n// 5. padding() や background() と組み合わせてスタイリング可能",
					"keywords": [
						"axis",
						"vertical",
						"horizontal",
						"multiline",
						"複数行",
						"展開",
						"方向",
						"テキストフィールド"
					]
				},
				{
					"title": "toggleStyle() - トグルスタイル",
					"code": "// トグルスタイルの種類\n@State private var isOn = false\n\nToggle(\"自動\", isOn: $isOn)\n    .toggleStyle(.automatic)          // 自動（プラットフォームに応じて）\n\nToggle(\"スイッチ\", isOn: $isOn)\n    .toggleStyle(.switch)             // スイッチ型\n\nToggle(\"ボタン\", isOn: $isOn)\n    .toggleStyle(.button)             // ボタン型\n\n// トグルの色を変更\nToggle(\"カスタム色\", isOn: $isOn)\n    .toggleStyle(.switch)\n    .tint(.purple)                    // 紫色のトグル",
					"keywords": ["switch", "button", "appearance", "input", "トグル", "スイッチ"]
				},
				{
					"title": "pickerStyle() - ピッカースタイル",
					"code": "// ピッカースタイルの種類\n@State private var selection = 0\nlet options = [\"オプション1\", \"オプション2\", \"オプション3\"]\n\nPicker(\"選択\", selection: $selection) {\n    ForEach(0..<options.count, id: \\.self) { index in\n        Text(options[index]).tag(index)\n    }\n}\n.pickerStyle(.automatic)              // 自動\n\nPicker(\"メニュー\", selection: $selection) { ... }\n.pickerStyle(.menu)                   // ドロップダウンメニュー\n\nPicker(\"セグメント\", selection: $selection) { ... }\n.pickerStyle(.segmented)              // セグメントコントロール\n\nPicker(\"ホイール\", selection: $selection) { ... }\n.pickerStyle(.wheel)                  // ホイール型\n\nPicker(\"インライン\", selection: $selection) { ... }\n.pickerStyle(.inline)                 // インライン表示",
					"keywords": [
						"menu",
						"wheel",
						"segmented",
						"selection",
						"dropdown",
						"選択",
						"ピッカー",
						"ドラムロール"
					]
				},
				{
					"title": "labelStyle() - ラベルスタイル",
					"code": "// ラベルスタイルの種類\nLabel(\"設定\", systemImage: \"gear\")\n    .labelStyle(.automatic)           // 自動（アイコン+テキスト）\n\nLabel(\"設定\", systemImage: \"gear\")\n    .labelStyle(.titleOnly)           // テキストのみ\n\nLabel(\"設定\", systemImage: \"gear\")\n    .labelStyle(.iconOnly)            // アイコンのみ\n\nLabel(\"設定\", systemImage: \"gear\")\n    .labelStyle(.titleAndIcon)        // テキスト+アイコン（明示的）\n\n// Labelの使用例\nButton {\n    // アクション\n} label: {\n    Label(\"追加\", systemImage: \"plus.circle.fill\")\n}\n.buttonStyle(.borderedProminent)",
					"keywords": ["icon", "text", "combination", "display", "ラベル", "アイコン"]
				},
				{
					"title": "contentShape() - タップ領域の定義",
					"code": "// contentShapeはタップ可能な領域を定義する\n// 透明な部分もタップを検知したい場合に使用\n\n// 問題: HStack内の余白部分はタップできない\nHStack {\n    Text(\"左\")\n    Spacer()\n    Text(\"右\")\n}\n.onTapGesture {\n    print(\"タップされました\")  // Spacer部分はタップ不可\n}\n\n// 解決: contentShapeで領域全体をタップ可能に\nHStack {\n    Text(\"左\")\n    Spacer()\n    Text(\"右\")\n}\n.contentShape(Rectangle())            // 四角形の領域全体をタップ可能に\n.onTapGesture {\n    print(\"タップされました\")  // Spacer部分もタップ可能\n}\n\n// Buttonでも同様に使用可能\nButton {\n    print(\"タップ\")\n} label: {\n    HStack {\n        Image(systemName: \"star\")\n        Spacer()\n        Text(\"お気に入り\")\n    }\n    .contentShape(Rectangle())        // ボタン全体をタップ可能に\n}\n.buttonStyle(.plain)\n\n// 様々な形状を指定可能\n.contentShape(Circle())               // 円形の領域\n.contentShape(Capsule())              // カプセル形状\n.contentShape(RoundedRectangle(cornerRadius: 10))  // 角丸四角形\n\n// インタラクションの種類を指定\n.contentShape(.interaction, Rectangle())     // タップ・ジェスチャー用\n.contentShape(.dragPreview, Rectangle())     // ドラッグプレビュー用\n.contentShape(.contextMenuPreview, Circle()) // コンテキストメニュー用",
					"keywords": ["hit testing", "tap area", "touch", "region", "タップ領域", "当たり判定"]
				},
				{
					"title": "navigationTitle() - ナビゲーションタイトル",
					"code": "// navigationTitle()はNavigationStack内でページのタイトルを設定する修飾子\n\n// === 基本的な使い方 ===\n\nNavigationStack {\n    Text(\"コンテンツ\")\n        .navigationTitle(\"ホーム\")       // ナビゲーションバーにタイトルを表示\n}\n\n// === 表示モードの切り替え ===\n\n// .large - 大きなタイトル（デフォルト、スクロールで縮小）\nNavigationStack {\n    List {\n        Text(\"項目1\")\n        Text(\"項目2\")\n    }\n    .navigationTitle(\"設定\")\n    .navigationBarTitleDisplayMode(.large)       // 大きいタイトル\n}\n\n// .inline - 小さなタイトル（常にナビゲーションバー内に表示）\nNavigationStack {\n    List {\n        Text(\"項目1\")\n        Text(\"項目2\")\n    }\n    .navigationTitle(\"詳細\")\n    .navigationBarTitleDisplayMode(.inline)      // 小さいタイトル\n}\n\n// .automatic - 自動（親ビューの設定を継承）\n.navigationBarTitleDisplayMode(.automatic)\n\n// === ナビゲーションバーのカスタマイズ ===\n\n// ツールバーにボタンを追加\nNavigationStack {\n    List {\n        Text(\"項目\")\n    }\n    .navigationTitle(\"リスト\")\n    .toolbar {\n        // 右上にボタン\n        ToolbarItem(placement: .topBarTrailing) {\n            Button(action: {}) {\n                Image(systemName: \"plus\")\n            }\n        }\n        // 左上にボタン\n        ToolbarItem(placement: .topBarLeading) {\n            Button(\"編集\") { }\n        }\n    }\n}\n\n// === 実践的な例 ===\n\n// リスト画面から詳細画面への遷移\nstruct ContentView: View {\n    let items = [\"りんご\", \"バナナ\", \"みかん\"]\n\n    var body: some View {\n        NavigationStack {\n            List(items, id: \\.self) { item in\n                NavigationLink(item) {\n                    // 遷移先のビュー\n                    Text(\"\\(item)の詳細\")\n                        .navigationTitle(item)                    // 遷移先のタイトル\n                        .navigationBarTitleDisplayMode(.inline)   // 詳細画面は小さいタイトル\n                }\n            }\n            .navigationTitle(\"フルーツ一覧\")   // 一覧画面のタイトル\n        }\n    }\n}\n\n// ナビゲーションバーを非表示にする\nNavigationStack {\n    Text(\"タイトルなし\")\n        .navigationTitle(\"隠れたタイトル\")\n        .toolbar(.hidden, for: .navigationBar)  // ナビゲーションバー自体を非表示",
					"keywords": [
						"navigationTitle",
						"navigation",
						"title",
						"bar",
						"toolbar",
						"large",
						"inline",
						"ナビゲーション",
						"タイトル",
						"ツールバー",
						"画面遷移"
					]
				},
				{
					"title": "Menu - メニューボタン",
					"code": "// Menu はタップするとアクションのリストが表示されるコンポーネント\n// ツールバーなどでよく使用される\n\n// === 基本的な使い方 ===\n\n// シンプルなメニュー\nMenu(\"メニュー\") {\n    Button(\"編集\") { }\n    Button(\"削除\") { }\n    Button(\"共有\") { }\n}\n\n// アイコン付きメニュー\nMenu {\n    Button(action: {}) {\n        Label(\"編集\", systemImage: \"pencil\")\n    }\n    Button(action: {}) {\n        Label(\"削除\", systemImage: \"trash\")\n    }\n    Button(action: {}) {\n        Label(\"共有\", systemImage: \"square.and.arrow.up\")\n    }\n} label: {\n    Image(systemName: \"ellipsis.circle\")\n        .font(.system(size: 24))\n}\n\n// === テキストと一緒に表示 ===\n\nMenu {\n    Button(\"昇順\") { }\n    Button(\"降順\") { }\n    Button(\"名前順\") { }\n} label: {\n    HStack {\n        Image(systemName: \"arrow.up.arrow.down\")\n        Text(\"ソート\")\n    }\n}\n\n// === セクション分け ===\n\nMenu(\"その他\") {\n    Section(\"編集\") {\n        Button(\"編集\", action: { })\n        Button(\"複製\", action: { })\n    }\n    \n    Section(\"削除\") {\n        Button(\"ゴミ箱へ移動\", action: { })\n        Button(\"完全に削除\", action: { })\n    }\n}\n\n// === 破壊的なアクション（赤色） ===\n\nMenu(\"アクション\") {\n    Button(\"完了\", action: { })\n    \n    Button(role: .destructive) {\n        Label(\"削除\", systemImage: \"trash\")\n    } action: {\n        // 削除処理\n    }\n}\n\n// === ツールバー内での使用（最も一般的） ===\n\nstruct ContentView: View {\n    @State private var sortBy = \"名前\"\n    \n    var body: some View {\n        NavigationStack {\n            List {\n                Text(\"項目1\")\n                Text(\"項目2\")\n                Text(\"項目3\")\n            }\n            .navigationTitle(\"リスト\")\n            .toolbar {\n                ToolbarItem(placement: .topBarTrailing) {\n                    Menu {\n                        Button(\"名前順\") { sortBy = \"名前\" }\n                        Button(\"日付順\") { sortBy = \"日付\" }\n                        Button(\"サイズ順\") { sortBy = \"サイズ\" }\n                    } label: {\n                        Image(systemName: \"arrow.up.arrow.down\")\n                    }\n                }\n            }\n        }\n    }\n}\n\n// === 実践的な例：複数のアクション ===\n\nstruct ArticleOptionsMenu: View {\n    @State private var isShowing = false\n    let articleId: String\n    \n    var body: some View {\n        Menu {\n            Button(action: { }) {\n                Label(\"読む\", systemImage: \"book\")\n            }\n            \n            Button(action: { }) {\n                Label(\"共有\", systemImage: \"square.and.arrow.up\")\n            }\n            \n            Button(action: { }) {\n                Label(\"お気に入り\", systemImage: \"star\")\n            }\n            \n            Divider()\n            \n            Button(role: .destructive, action: { }) {\n                Label(\"削除\", systemImage: \"trash\")\n            }\n        } label: {\n            Image(systemName: \"ellipsis\")\n                .foregroundStyle(.blue)\n        }\n    }\n}\n\n// === Pickerのメニュースタイル との違い ===\n\n// Menu は単なるボタンのリスト\nMenu(\"アクション\") {\n    Button(\"アクション1\") { }\n    Button(\"アクション2\") { }\n}\n\n// Picker でメニュースタイルを使用すると、選択状態を管理できる\n@State private var selection = 0\nlet options = [\"オプション1\", \"オプション2\", \"オプション3\"]\n\nPicker(\"選択\", selection: $selection) {\n    ForEach(0..<options.count, id: \\.self) { index in\n        Text(options[index]).tag(index)\n    }\n}\n.pickerStyle(.menu)  // メニューのような表示だが、選択状態を管理",
					"keywords": [
						"menu",
						"action",
						"dropdown",
						"ellipsis",
						"toolbar",
						"button",
						"options",
						"メニュー",
						"アクション",
						"ドロップダウン",
						"ボタン",
						"その他"
					]
				}
			]
		},
		{
			"id": "icons",
			"title": "SF Symbols（アイコン）",
			"description": "SwiftUIで使用できるシステムアイコン（SF Symbols）のスタイリング方法です。",
			"codeBlocks": [
				{
					"title": "Image(systemName:) - SF Symbolsの基本",
					"code": "// SF Symbolsを表示する基本的な方法\n// systemName引数にアイコン名を指定\n\n// === 基本的な使い方 ===\n\n// チェックマークアイコン\nImage(systemName: \"checkmark.circle\")\n\n// リストアイコン\nImage(systemName: \"list.bullet\")\n\n// スター（お気に入り）\nImage(systemName: \"star.fill\")\n\n// 設定（ギア）\nImage(systemName: \"gear\")\n\n// ハート\nImage(systemName: \"heart.fill\")\n\n// === よく使用されるアイコン名 ===\n\n// チェック関連\nImage(systemName: \"checkmark\")         // チェックマーク\nImage(systemName: \"checkmark.circle\") // 丸いチェック\nImage(systemName: \"checkmark.circle.fill\") // 塗りつぶされた丸いチェック\nImage(systemName: \"xmark\")             // バツ印\nImage(systemName: \"xmark.circle\")     // 丸いバツ\n\n// リスト関連\nImage(systemName: \"list.bullet\")      // 箇条書きリスト\nImage(systemName: \"list.number\")      // 番号付きリスト\nImage(systemName: \"checklist\")        // チェックリスト\n\n// 追加・削除\nImage(systemName: \"plus\")              // プラス\nImage(systemName: \"plus.circle\")      // 丸いプラス\nImage(systemName: \"plus.circle.fill\") // 塗りつぶされた丸いプラス\nImage(systemName: \"minus\")             // マイナス\nImage(systemName: \"trash\")             // ゴミ箱\n\n// UI制御\nImage(systemName: \"slider.horizontal.3\") // スライダー\nImage(systemName: \"toggle.2\")          // トグルスイッチ\nImage(systemName: \"square.and.pencil\") // 編集\n\n// === 複合的な使用例 ===\n\n// アイコン付きボタン\nButton(action: {}) {\n    HStack {\n        Image(systemName: \"star.fill\")\n        Text(\"お気に入り\")\n    }\n}\n\n// アイコン付きラベル\nLabel(\"完了\", systemImage: \"checkmark.circle.fill\")",
					"keywords": [
						"icon",
						"symbol",
						"systemName",
						"SF",
						"image",
						"checkmark.circle",
						"list.bullet",
						"star.fill",
						"gear",
						"heart.fill",
						"checkmark.circle.fill",
						"xmark.circle",
						"plus",
						"minus",
						"trash",
						"アイコン",
						"シンボル"
					]
				},
				{
					"title": ".font() - アイコンのサイズと太さ指定",
					"code": "// アイコンのサイズか太さを指定する\n\n// === システムフォントスタイルでサイズ指定 ===\n\n// 小サイズ\nImage(systemName: \"checkmark.circle\")\n    .font(.caption)       // 12pt\n\n// 中サイズ\nImage(systemName: \"checkmark.circle\")\n    .font(.body)          // 17pt\n\n// 大サイズ\nImage(systemName: \"checkmark.circle\")\n    .font(.title)         // 28pt\n\n// 最大サイズ\nImage(systemName: \"checkmark.circle\")\n    .font(.largeTitle)    // 34pt\n\n// === カスタムサイズ指定 ===\n\n// 特定の大きさに設定\nImage(systemName: \"checkmark.circle\")\n    .font(.system(size: 48))  // 48ptに設定\n\n// === 太さ（weight）の指定 ===\n\n// デフォルト（regular）\nImage(systemName: \"checkmark.circle\")\n    .font(.system(size: 24))\n\n// 太文字\nImage(systemName: \"checkmark.circle\")\n    .font(.system(size: 24, weight: .bold))\n\n// 細文字\nImage(systemName: \"checkmark.circle\")\n    .font(.system(size: 24, weight: .light))\n\n// === 実践的な例 ===\n\n// タスク完了画面のアイコン\nVStack {\n    Image(systemName: \"checkmark.circle\")\n        .font(.system(size: 60))  // 大きく表示\n        .foregroundStyle(.green)\n    \n    Text(\"完了しました\")\n        .font(.title2)\n}\n\n// リスト内のステータスアイコン\nHStack {\n    Image(systemName: \"checkmark.circle.fill\")  // 完了済み\n        .font(.system(size: 20))\n        .foregroundStyle(.green)\n    \n    Text(\"タスク1\")\n}\n\n// ナビゲーション用のアイコン\nButton(action: {}) {\n    Image(systemName: \"list.bullet\")\n        .font(.system(size: 18, weight: .semibold))\n        .foregroundStyle(.blue)\n}",
					"keywords": [
						"size",
						"weight",
						"font",
						"scale",
						"bold",
						"checkmark.circle",
						"checkmark.circle.fill",
						"list.bullet",
						"サイズ",
						"太さ",
						"フォント"
					]
				},
				{
					"title": ".foregroundStyle() - アイコンの色指定",
					"code": "// アイコンの色を指定する\n\n// === 基本的な色を使用 ===\n\n// 赤\nImage(systemName: \"checkmark.circle\")\n    .foregroundStyle(.red)\n\n// 青\nImage(systemName: \"list.bullet\")\n    .foregroundStyle(.blue)\n\n// 緑（完了を表現）\nImage(systemName: \"checkmark.circle.fill\")\n    .foregroundStyle(.green)\n\n// グレー（無効状態）\nImage(systemName: \"xmark.circle\")\n    .foregroundStyle(.gray)\n\n// === カスタムカラー ===\n\n// RGB値で指定\nImage(systemName: \"star.fill\")\n    .foregroundStyle(Color(red: 1.0, green: 0.8, blue: 0.0))  // 黄色\n\n// 透明度付き\nImage(systemName: \"checkbox.circle\")\n    .foregroundStyle(.blue.opacity(0.7))\n\n// === アクセントカラー ===\n\n// アプリで定義されたアクセントカラー\nImage(systemName: \"gear\")\n    .foregroundStyle(.accentColor)\n\n// === グラデーション ===\n\n// 線形グラデーション\nImage(systemName: \"heart.fill\")\n    .foregroundStyle(\n        LinearGradient(\n            colors: [.red, .pink],\n            startPoint: .topLeading,\n            endPoint: .bottomTrailing\n        )\n    )\n\n// === 実践的な例 ===\n\n// ステータスを色で表現\nHStack(spacing: 12) {\n    // 完了\n    Image(systemName: \"checkmark.circle.fill\")\n        .foregroundStyle(.green)\n    \n    // 未完了\n    Image(systemName: \"circle\")\n        .foregroundStyle(.gray)\n    \n    // エラー\n    Image(systemName: \"xmark.circle.fill\")\n        .foregroundStyle(.red)\n}\n\n// 画面内でのアイコンの色分け\nVStack(spacing: 16) {\n    // 肯定的なアクション（完了）\n    Image(systemName: \"checkmark.circle\")\n        .font(.system(size: 32))\n        .foregroundStyle(.green)\n    \n    // 否定的なアクション（キャンセル）\n    Image(systemName: \"xmark.circle\")\n        .font(.system(size: 32))\n        .foregroundStyle(.red)\n    \n    // 中立的なアクション（設定）\n    Image(systemName: \"gear\")\n        .font(.system(size: 32))\n        .foregroundStyle(.blue)\n}",
					"keywords": [
						"color",
						"foregroundColor",
						"style",
						"tint",
						"checkmark.circle",
						"checkmark.circle.fill",
						"xmark.circle",
						"list.bullet",
						"star.fill",
						"gear",
						"heart.fill",
						"色",
						"カラー",
						"着色"
					]
				},
				{
					"title": "複合修飾子 - アイコンの完全なスタイリング",
					"code": "// 複数の修飾子を組み合わせてアイコンを完全にスタイリング\n\n// === 基本的な組み合わせ ===\n\n// サイズ + 色\nImage(systemName: \"star.fill\")\n    .font(.system(size: 24))\n    .foregroundStyle(.yellow)\n\n// サイズ + 色 + パディング\nImage(systemName: \"checkmark.circle.fill\")\n    .font(.system(size: 32))\n    .foregroundStyle(.green)\n    .padding(12)\n    .background(\n        Circle()\n            .fill(.green.opacity(0.1))\n    )\n    .clipShape(Circle())\n\n// === 複雑なスタイリング例 ===\n\n// タスク完了表示\nVStack(spacing: 16) {\n    Image(systemName: \"checkmark.circle\")\n        .font(.system(size: 60, weight: .bold))\n        .foregroundStyle(.green)\n    \n    Text(\"完了しました\")\n        .font(.title2)\n        .fontWeight(.semibold)\n}\n.padding(32)\n.background(\n    RoundedRectangle(cornerRadius: 16)\n        .fill(.green.opacity(0.1))\n)\n\n// リストアイテムのステータスアイコン\nHStack(spacing: 12) {\n    Image(systemName: \"checkmark.circle.fill\")\n        .font(.system(size: 20, weight: .semibold))\n        .foregroundStyle(.green)\n    \n    VStack(alignment: .leading, spacing: 4) {\n        Text(\"タスク1\")\n            .font(.headline)\n        Text(\"完了日時: 2026年2月19日\")\n            .font(.caption)\n            .foregroundStyle(.gray)\n    }\n    \n    Spacer()\n}\n.padding()\n.background(\n    RoundedRectangle(cornerRadius: 8)\n        .fill(Color(.systemGray6))\n)\n\n// トグルボタン\nButton(action: {}) {\n    HStack(spacing: 8) {\n        Image(systemName: \"checkmark.circle.fill\")\n            .font(.system(size: 18))\n            .foregroundStyle(.blue)\n        \n        Text(\"マーク\")\n            .font(.callout)\n            .fontWeight(.medium)\n    }\n    .padding(.vertical, 8)\n    .padding(.horizontal, 12)\n    .background(\n        RoundedRectangle(cornerRadius: 6)\n            .stroke(.blue, lineWidth: 1.5)\n    )\n}\n\n// EmptyState表示\nVStack(spacing: 16) {\n    Image(systemName: \"list.bullet\")\n        .font(.system(size: 48))\n        .foregroundStyle(.gray)\n    \n    Text(\"タスクがありません\")\n        .font(.headline)\n        .foregroundStyle(.gray)\n    \n    Text(\"新しいタスクを追加してください\")\n        .font(.caption)\n        .foregroundStyle(.gray.opacity(0.7))\n}\n.frame(maxWidth: .infinity, maxHeight: .infinity)",
					"keywords": [
						"combination",
						"composite",
						"multiple",
						"modifier",
						"複合",
						"結合",
						"パッケージング"
					]
				},
				{
					"title": "scaleEffect() - アイコンのスケーリング",
					"code": "// scaleEffect()を使用してアイコンを拡大・縮小する\n\n// === 基本的なスケーリング ===\n\n// 1.5倍に拡大\nImage(systemName: \"star.fill\")\n    .scaleEffect(1.5)\n\n// 0.8倍に縮小\nImage(systemName: \"checkmark.circle\")\n    .scaleEffect(0.8)\n\n// === X軸とY軸を別々に指定 ===\n\n// X方向のみ2倍（横長）\nImage(systemName: \"arrow.right\")\n    .scaleEffect(x: 2.0, y: 1.0)\n\n// Y方向のみ2倍（縦長）\nImage(systemName: \"arrow.up\")\n    .scaleEffect(x: 1.0, y: 2.0)\n\n// === アニメーションと組み合わせ ===\n\nstruct ScaleAnimationExample: View {\n    @State private var isPressed = false\n    \n    var body: some View {\n        Button(action: {\n            isPressed.toggle()\n        }) {\n            Image(systemName: \"heart.fill\")\n                .font(.system(size: 32))\n                .foregroundStyle(.red)\n                .scaleEffect(isPressed ? 1.2 : 1.0)  // タップで拡大\n                .animation(.spring(response: 0.3, dampingFraction: 0.6), value: isPressed)\n        }\n    }\n}\n\n// === 実践的な例 ===\n\n// ハイライト表示\nImage(systemName: \"star.fill\")\n    .font(.system(size: 24))\n    .foregroundStyle(.yellow)\n    .scaleEffect(1.2)  // 少し大きく表示\n\n// 注目を集めるアイコン\nVStack {\n    Image(systemName: \"exclamationmark.circle.fill\")\n        .font(.system(size: 40))\n        .foregroundStyle(.orange)\n        .scaleEffect(1.1)\n    \n    Text(\"注意\")\n        .font(.headline)\n}\n\n// === fontと併用する場合 ===\n\n// font()で基本サイズを設定してからscaleEffect()で調整\nImage(systemName: \"checkmark.circle\")\n    .font(.system(size: 24))\n    .scaleEffect(1.5)  // 24 * 1.5 = 36ptになる\n    .foregroundStyle(.green)",
					"keywords": [
						"scale",
						"size",
						"zoom",
						"enlarge",
						"shrink",
						"star.fill",
						"checkmark.circle",
						"heart.fill",
						"拡大",
						"縮小",
						"スケール"
					]
				}
			]
		}
	]
}
