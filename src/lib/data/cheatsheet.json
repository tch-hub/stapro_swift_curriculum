{
	"sections": [
		{
			"id": "basic-syntax",
			"title": "基本構文",
			"description": "変数、定数、データ型の基本です。",
			"codeBlocks": [
				{
					"title": "変数と定数",
					"code": "// Swiftでは、定数（let）と変数（var）を宣言できます\n// 定数の宣言（値を変更できない）\nlet schoolName = \"中央中学校\"  // 学校名を定数として宣言\nlet pi = 3.14159  // 円周率も定数\n\n// 変数の宣言（値を変更できる）\nvar score = 85  // スコアを変数として宣言\nvar isStudying = true  // 勉強中かどうかを変数で管理\n\n// データ型を明示的に指定することも可能\nvar height: Double = 165.5  // 身長をDouble型で宣言\nvar weight: Int = 50  // 体重をInt型で宣言\n\n// print関数を使って値を出力\nprint(\"学校名: \\(schoolName)\")  // 文字列補間を使って変数を埋め込み\nprint(\"スコア: \\(score)\")\nprint(\"勉強中: \\(isStudying)\")\nprint(\"身長: \\(height)cm\")\nprint(\"体重: \\(weight)kg\")",
					"output": "学校名: 中央中学校\nスコア: 85\n勉強中: true\n身長: 165.5cm\n体重: 50kg",
					"executable": true,
					"keywords": ["variable", "constant", "let", "var", "宣言", "定義", "変数", "定数"]
				},
				{
					"title": "定数への再代入（エラー例）",
					"code": "// 定数の宣言\nlet schoolName = \"中央中学校\"\n\n// 定数への再代入はエラーになる\nschoolName = \"東京中学校\"",
					"output": "error: cannot assign to value: 'schoolName' is a 'let' constant\nschoolName = \"東京中学校\"\n^^^^^^^^^^\nnote: change 'let' to 'var' to make it mutable",
					"executable": true,
					"keywords": ["error", "reassignment", "let", "change", "変更", "エラー", "再代入"]
				},
				{
					"title": "列挙型（Enum）",
					"code": "// 列挙型（Enum）は、関連する値をグループ化する型です\n// 基本的な列挙型の定義\nenum Direction {\n    case north  // 北\n    case south  // 南\n    case east   // 東\n    case west   // 西\n}\n\n// 短縮形での定義（1行で複数のcaseを定義）\nenum Direction {\n    case north, south, east, west\n}\n\n// enumの使用例\nlet currentDirection = Direction.north  // 北方向を指定\n\n// switch文を使ってenumの値を処理\nswitch currentDirection {\ncase .north:\n    print(\"北へ進む\")  // northの場合の処理\ncase .south:\n    print(\"南へ進む\")  // southの場合の処理\ncase .east:\n    print(\"東へ進む\")  // eastの場合の処理\ncase .west:\n    print(\"西へ進む\")  // westの場合の処理\n}\n\n// 生の値（raw value）を持つenumの例\nenum Planet: Int {  // Int型のraw valueを持つ\n    case mercury = 1  // 水星\n    case venus = 2    // 金星\n    case earth = 3    // 地球\n    case mars = 4     // 火星\n}\n\nlet earthNumber = Planet.earth.rawValue  // rawValueで数値を取得\nprint(\"地球の番号: \\(earthNumber)\")",
					"output": "北へ進む\n地球の番号: 3",
					"executable": true,
					"keywords": ["enum", "case", "switch", "列挙", "イナム", "エナム"]
				}
			]
		},
		{
			"id": "types",
			"title": "型",
			"description": "Swiftのデータ型について学びます。",
			"codeBlocks": [
				{
					"title": "基本型",
					"code": "// Swiftの基本的なデータ型\n// 整数型（Int）- 正負の整数を扱う\nlet age: Int = 13  // 年齢（整数）\nlet score: Int = 85  // スコア（整数）\n\n// 浮動小数点型（Double, Float）- 小数点を扱う\nlet height: Double = 165.5  // 身長（倍精度浮動小数点）\nlet weight: Float = 50.5    // 体重（単精度浮動小数点）\n\n// 論理型（Bool）- trueまたはfalseの値\nlet isStudent: Bool = true   // 学生かどうか\nlet hasHomework: Bool = false  // 宿題があるかどうか\n\n// 文字列型（String）- 文字の並び\nlet name: String = \"太郎\"  // 名前\nlet message: String = \"こんにちは\"  // メッセージ\n\n// 文字型（Character）- 単一の文字\nlet grade: Character = \"A\"  // 成績\nlet symbol: Character = \"★\"  // 記号\n\n// 値の出力\nprint(\"年齢: \\(age)歳\")\nprint(\"身長: \\(height)cm\")\nprint(\"学生: \\(isStudent)\")\nprint(\"名前: \\(name)\")\nprint(\"成績: \\(grade)\")",
					"output": "年齢: 13歳\n身長: 165.5cm\n学生: true\n名前: 太郎\n成績: A",
					"executable": true,
					"keywords": [
						"Int",
						"Double",
						"String",
						"Bool",
						"型",
						"type",
						"integer",
						"boolean",
						"数値",
						"文字"
					]
				},
				{
					"title": "型の確認（type(of:)関数）",
					"code": "// type(of:)関数を使って変数の型を確認する\nlet number = 42\nlet decimal = 3.14\nlet text = \"Hello\"\nlet flag = true\n\nprint(\"numberの型: \\(type(of: number))\")  // Int型\nprint(\"decimalの型: \\(type(of: decimal))\")  // Double型\nprint(\"textの型: \\(type(of: text))\")      // String型\nprint(\"flagの型: \\(type(of: flag))\")      // Bool型",
					"output": "numberの型: Int\ndecimalの型: Double\ndecimalの型: String\nflagの型: Bool",
					"executable": true,
					"keywords": ["type(of:)", "check", "確認", "型確認"]
				},
				{
					"title": "タプル（Tuple）",
					"code": "// タプルは複数の値をグループ化する型\n// 生徒の情報をタプルで表現\nlet student: (String, Int, String) = (\"太郎\", 13, \"中学1年\")\nlet point: (x: Int, y: Int) = (x: 10, y: 20)\n\n// インデックスでアクセス\nprint(\"名前: \\(student.0)\")  // 最初の要素（太郎）\nprint(\"年齢: \\(student.1)\")  // 2番目の要素（13）\nprint(\"学年: \\(student.2)\")  // 3番目の要素（中学1年）\n\n// ラベル付きでアクセス\nprint(\"X座標: \\(point.x)\")  // xラベルでアクセス\nprint(\"Y座標: \\(point.y)\")  // yラベルでアクセス\n\n// 分解して代入\nlet (name, age, grade) = student\nprint(\"\\(name)は\\(age)歳の\\(grade)生です\")",
					"output": "名前: 太郎\n年齢: 13\n学年: 中学1年\nX座標: 10\nY座標: 20\n太郎は13歳の中学1年生です",
					"executable": true,
					"keywords": ["tuple", "multiple", "values", "pair", "組", "タプル"]
				},
				{
					"title": "型の変換（キャスト）",
					"code": "// 異なる型同士の変換（キャスト）\n// IntからDoubleへの変換\nlet intValue = 42\nlet doubleValue = Double(intValue)  // IntからDoubleに変換\nprint(\"IntからDouble: \\(doubleValue)\")  // 42.0\n\n// DoubleからIntへの変換（小数点以下切り捨て）\nlet decimalValue = 3.9\nlet intFromDouble = Int(decimalValue)  // DoubleからIntに変換\nprint(\"DoubleからInt: \\(intFromDouble)\")  // 3\n\n// StringからIntへの変換（失敗する可能性あり）\nlet numberString = \"123\"\nif let convertedNumber = Int(numberString) {\n    print(\"StringからInt: \\(convertedNumber)\")  // 変換成功\n} else {\n    print(\"変換できませんでした\")\n}\n\n// IntからStringへの変換\nlet numberToString = String(intValue)\nprint(\"IntからString: \\(numberToString)\")",
					"output": "IntからDouble: 42.0\nDoubleからInt: 3\nStringからInt: 123\nIntからString: 42",
					"executable": true,
					"keywords": [
						"cast",
						"convert",
						"Double(int)",
						"Int(double)",
						"String(int)",
						"変換",
						"キャスト"
					]
				},
				{
					"title": "範囲型（Range）",
					"code": "// 範囲型は連続した値の範囲を表す型\n// ClosedRangeは開始値と終了値を含む範囲（...演算子）\nlet closedRange: ClosedRange<Int> = 1...5  // 1, 2, 3, 4, 5を含む範囲\nprint(\"ClosedRange: \\(closedRange)\")  // 1...5と表示される\n\n// 範囲を使ったループ\nprint(\"範囲内の値:\")\nfor number in closedRange {\n    print(\"\\(number)\", terminator: \" \")  // 1 2 3 4 5 と出力\n}\nprint()  // 改行\n\n// 範囲に値が含まれるかチェック\nlet testValue = 3\nif closedRange.contains(testValue) {\n    print(\"\\(testValue)は範囲内に含まれます\")  // 3は範囲内に含まれる\n}\n\n// 範囲の境界値を取得\nprint(\"開始値: \\(closedRange.lowerBound)\")  // 1\nprint(\"終了値: \\(closedRange.upperBound)\")  // 5\n\n// 半開範囲（..<演算子）との比較\nlet halfOpenRange = 1..<5  // 1, 2, 3, 4を含む（5を含まない）\nprint(\"Half-open range: \\(halfOpenRange)\")  // 1..<5\n\n// 文字の範囲も可能\nlet charRange: ClosedRange<Character> = \"a\"...\"z\"\nprint(\"文字の範囲: \\(charRange.contains(\\\"m\\\"))\")  // true",
					"output": "ClosedRange: 1...5\n範囲内の値:\n1 2 3 4 5\n3は範囲内に含まれます\n開始値: 1\n終了値: 5\nHalf-open range: 1..<5\n文字の範囲: true",
					"executable": true,
					"keywords": ["range", "closed", "half-open", "...", "..<", "範囲"]
				},
				{
					"title": "Void型",
					"code": "// Voidは「値がない」ことを表す特別な型です\n// () と書く「空のタプル」と同じ意味です\n\n// 1. 関数の戻り値（通常は省略されます）\nfunc greet() -> Void {\n    print(\"こんにちは\")\n}\n\n// 2. クロージャの型定義（よく使われます）\n// 「引数なし、戻り値なし」の処理を表現します\n// 例: let onToggle: () -> Void\n\nvar action: () -> Void = {\n    print(\"アクション実行\")\n}\n\n// 実行\ngreet()\naction()",
					"output": "こんにちは\nアクション実行",
					"executable": true,
					"keywords": ["void", "empty", "tuple", "return", "closure", "型", "空", "戻り値なし"]
				}
			]
		},
		{
			"id": "operators",
			"title": "演算子",
			"description": "計算や比較に使う記号です。",
			"codeBlocks": [
				{
					"title": "算術演算子",
					"code": "// 算術演算子を使って数値の計算を行う\nlet a = 10  // 変数aに10を代入\nlet b = 3   // 変数bに3を代入\n\nlet sum = a + b        // 加算（和）: 10 + 3 = 13\nlet difference = a - b // 減算（差）: 10 - 3 = 7\nlet product = a * b    // 乗算（積）: 10 * 3 = 30\nlet quotient = a / b   // 除算（商）: 10 / 3 = 3（整数除算なので小数点以下切り捨て）\nlet remainder = a % b  // 剰余（余り）: 10 % 3 = 1\n\n// 計算結果を出力\nprint(\"和: \\(sum)\")\nprint(\"差: \\(difference)\")\nprint(\"積: \\(product)\")\nprint(\"商: \\(quotient)\")\nprint(\"余り: \\(remainder)\")",
					"output": "和: 13\n差: 7\n積: 30\n商: 3\n余り: 1",
					"executable": true,
					"keywords": [
						"+",
						"-",
						"*",
						"/",
						"%",
						"math",
						"calculation",
						"計算",
						"足し算",
						"引き算",
						"掛け算",
						"割り算"
					]
				},
				{
					"title": "比較演算子",
					"code": "// 比較演算子を使って値の大小や等しさを比較する\nlet x = 5   // 変数xに5を代入\nlet y = 10  // 変数yに10を代入\n\nprint(\"x == y: \\(x == y)\")  // 等しい（xはyと等しいか？）: false\nprint(\"x != y: \\(x != y)\")  // 等しくない（xはyと等しくないか？）: true\nprint(\"x < y: \\(x < y)\")   // より小さい（xはyより小さいか？）: true\nprint(\"x > y: \\(x > y)\")   // より大きい（xはyより大きいか？）: false\nprint(\"x <= y: \\(x <= y)\")  // 以下（xはy以下か？）: true\nprint(\"x >= y: \\(x >= y)\")  // 以上（xはy以上か？）: false",
					"output": "x == y: false\nx != y: true\nx < y: true\nx > y: false\nx <= y: true\nx >= y: false",
					"executable": true,
					"keywords": ["==", "!=", "<", ">", "compare", "equal", "比較", "等しい", "大小"]
				},
				{
					"title": "三項演算子",
					"code": "// 三項演算子は条件式 ? 真の値 : 偽の値 の形式で、条件によって値を選択する\nlet score = 85  // テストのスコア\n\n// 条件に基づいて値を選択（60点以上なら合格、そうでなければ不合格）\nlet result = score >= 60 ? \"合格\" : \"不合格\"\nprint(\"テスト結果: \\(result)\")\n\n// 数値の比較（aとbのうち大きい方を選択）\nlet a = 10\nlet b = 20\nlet max = a > b ? a : b  // aがbより大きい場合はa、そうでなければb\nprint(\"大きい方の値: \\(max)\")\n\n// 文字列の選択（学生かどうかに応じてメッセージを選択）\nlet isStudent = true\nlet message = isStudent ? \"学生です\" : \"学生ではありません\"\nprint(message)",
					"output": "テスト結果: 合格\n大きい方の値: 20\n学生です",
					"executable": true,
					"keywords": ["ternary", "?:", "condition", "if-else", "operator", "条件演算子", "三項"]
				},
				{
					"title": "論理演算子",
					"code": "// 論理演算子は、条件を組み合わせるために使います\nlet age = 15\nlet hasTicket = true\n\n// &&（AND）: 両方の条件がtrueのときにtrue\nif age >= 13 && hasTicket {\n    print(\"入場できます\")  // 13歳以上 かつ チケットあり\n}\n\n// ||（OR）: どちらかの条件がtrueのときにtrue\nlet isStudent = true\nlet isSenior = false\nif isStudent || isSenior {\n    print(\"割引が適用されます\")  // 学生 または シニア\n}\n\n// !（NOT）: 条件を反転させる（trueをfalse、falseをtrueに）\nlet isLoggedIn = false\nif !isLoggedIn {\n    print(\"ログインしてください\")  // ログインしていない場合\n}\n\n// 組み合わせの例\nlet score = 85\nlet attendance = 90\nif score >= 80 && attendance >= 80 {\n    print(\"優秀です\")\n} else if score >= 80 || attendance >= 80 {\n    print(\"あと少し\")\n}",
					"output": "入場できます\n割引が適用されます\nログインしてください\n優秀です",
					"executable": true,
					"keywords": [
						"&&",
						"||",
						"!",
						"and",
						"or",
						"not",
						"logical",
						"論理",
						"かつ",
						"または",
						"否定"
					]
				}
			]
		},
		{
			"id": "control-structures",
			"title": "制御構造",
			"description": "プログラムの流れを制御します。",
			"codeBlocks": [
				{
					"title": "if文",
					"code": "// if文を使って条件分岐を行う\nlet age = 13  // 年齢\n\n// 基本的なif-else文（13歳以上なら中学生、そうでなければ小学生）\nif age >= 13 {\n    print(\"中学生です\")\n} else {\n    print(\"小学生です\")\n}\n\n// 複数の条件をチェックするif-else if-else文\nif age >= 18 {\n    print(\"大人\")  // 18歳以上は大人\n} else if age >= 13 {\n    print(\"中学生\")  // 13-17歳は中学生\n} else {\n    print(\"小学生\")  // 12歳以下は小学生\n}",
					"output": "中学生です\n中学生",
					"executable": true,
					"keywords": ["condition", "else", "branch", "条件", "分岐", "if"]
				},
				{
					"title": "for-inループ",
					"code": "// for-inループを使ってコレクションの要素を順番に処理する\nlet fruits = [\"りんご\", \"バナナ\", \"オレンジ\"]  // 果物の配列\n\n// 配列の各要素を順番に処理\nfor fruit in fruits {\n    print(\"好きな果物: \\(fruit)\")\n}\n\n// 範囲を使ったループ（1から5までの数字を順番に処理）\nfor i in 1...5 {  // 1, 2, 3, 4, 5の順にiに代入される\n    print(\"\\(i)回目のループ\")\n}",
					"output": "好きな果物: りんご\n好きな果物: バナナ\n好きな果物: オレンジ\n1回目のループ\n2回目のループ\n3回目のループ\n4回目のループ\n5回目のループ",
					"executable": true,
					"keywords": ["loop", "iteration", "repeat", "繰り返し", "ループ", "for"]
				}
			]
		},
		{
			"id": "functions",
			"title": "関数",
			"description": "処理をまとめて再利用できるようにします。",
			"codeBlocks": [
				{
					"title": "関数の定義と呼び出し",
					"code": "// funcキーワードを使って関数を定義する\n// 挨拶をする関数（名前を受け取って挨拶文を返す）\nfunc greet(name: String) -> String {\n    return \"こんにちは、\\(name)さん!\"  // 挨拶文を返す\n}\n\n// 計算を行う関数（2つの整数を受け取ってその和を返す）\nfunc add(a: Int, b: Int) -> Int {\n    return a + b  // a + bの結果を返す\n}\n\n// 関数の実行（呼び出し）\nlet message = greet(name: \"太郎\")  // greet関数を呼び出し、結果をmessageに代入\nlet result = add(a: 10, b: 5)     // add関数を呼び出し、結果をresultに代入\n\nprint(message)  // 挨拶文を出力\nprint(\"10 + 5 = \\(result)\")  // 計算結果を出力",
					"output": "こんにちは、太郎さん!\n10 + 5 = 15",
					"executable": true,
					"keywords": [
						"func",
						"return",
						"arguments",
						"parameters",
						"call",
						"定義",
						"呼び出し",
						"関数",
						"引数",
						"戻り値"
					]
				},
				{
					"title": "静的メソッド（static func）",
					"code": "// staticキーワードはインスタンスを作らずにクラス名から直接関数を呼べるようにします\n\n// === 基本的な使い方 ===\n\nclass MathHelper {\n    // 通常のメソッド（インスタンスが必要）\n    func multiply(a: Int, b: Int) -> Int {\n        return a * b\n    }\n    \n    // staticメソッド（インスタンス不要）\n    static func add(a: Int, b: Int) -> Int {\n        return a + b\n    }\n}\n\n// 呼び出し方の比較\nlet helper = MathHelper()  // インスタンスを作成\nprint(\"5 × 3 = \\(helper.multiply(a: 5, b: 3))\")  // インスタンスから呼ぶ\nprint(\"5 + 3 = \\(MathHelper.add(a: 5, b: 3))\")   // クラス名から直接呼ぶ\n\n// === ToDoタスクサービスの例 ===\n\nclass ToDoTaskService {\n    // タスクを追加する（インスタンス不要）\n    static func addTask(title: String) -> String {\n        return \"タスク『\\(title)』を追加しました\"\n    }\n    \n    // タスクを削除する（インスタンス不要）\n    static func deleteTask(id: Int) -> String {\n        return \"タスク（ID:\\(id)）を削除しました\"\n    }\n}\n\n// staticメソッドは直接クラス名で呼べるので便利\nprint(ToDoTaskService.addTask(title: \"勉強\"))\nprint(ToDoTaskService.deleteTask(id: 1))\n\n// === staticプロパティの例 ===\n\nclass Configuration {\n    // 全インスタンスで共通の値\n    static let appName = \"ToDoApp\"\n    static let version = \"1.0.0\"\n    // インスタンスごとに異なる値\n    var userId: String\n    \n    init(userId: String) {\n        self.userId = userId\n    }\n}\n\nprint(\"アプリ: \\(Configuration.appName) v\\(Configuration.version)\")",
					"output": "5 × 3 = 15\n5 + 3 = 8\nタスク『勉強』を追加しました\nタスク（ID:1）を削除しました\nアプリ: ToDoApp v1.0.0",
					"executable": true,
					"keywords": [
						"static",
						"func",
						"class method",
						"インスタンス不要",
						"静的",
						"クラスメソッド",
						"サービス"
					]
				}
			]
		},
		{
			"id": "underscore",
			"title": "_（アンダースコア）",
			"description": "_（アンダースコア）はSwiftで「無視する・省略する」を意味する特別な記号です。引数ラベルの省略はSwift独自の使い方で、SwiftUI全体で頻出します。",
			"codeBlocks": [
				{
					"title": "引数ラベルの省略（Swift独自）",
					"code": "// 通常の関数: 呼び出し時にラベルが必要\nfunc greet(name: String) -> String {\n    return \"こんにちは、\\(name)さん!\"\n}\nprint(greet(name: \"太郎\"))  // ラベル「name:」が必要\n\n// _ をつけた関数: ラベルを省略できる\nfunc hello(_ name: String) -> String {\n    return \"Hello, \\(name)!\"\n}\nprint(hello(\"花子\"))  // ラベルなしで呼べる\n\n// 複数引数での使い分け\nfunc add(_ a: Int, _ b: Int) -> Int {\n    return a + b\n}\nprint(add(3, 5))  // 両方ラベル省略\n\n// SwiftUIでよく見るパターン\n// .onChange(of: value) { _, newValue in ... }\n// Image(systemName: \"star\")  ← systemNameはラベルあり",
					"output": "こんにちは、太郎さん!\nHello, 花子!\n8",
					"executable": true,
					"keywords": ["underscore", "label", "argument", "ラベル", "省略", "アンダースコア", "_"]
				},
				{
					"title": "値の無視（ワイルドカード）",
					"code": "// 1. ループで値を使わない場合\nfor _ in 1...3 {\n    print(\"繰り返し\")  // 回数だけ必要で、値は不要\n}\n\n// 2. 戻り値を無視する場合\nfunc doSomething() -> Int {\n    print(\"処理実行\")\n    return 42\n}\nlet _ = doSomething()  // 戻り値を使わないことを明示\n\n// 3. タプルの一部を無視\nlet (name, _, grade) = (\"太郎\", 13, \"中学1年\")\nprint(\"\\(name)は\\(grade)生です\")  // 年齢(13)は無視",
					"output": "繰り返し\n繰り返し\n繰り返し\n処理実行\n太郎は中学1年生です",
					"executable": true,
					"keywords": ["wildcard", "ignore", "discard", "無視", "ワイルドカード"]
				}
			]
		},
		{
			"id": "collections",
			"title": "コレクション",
			"description": "複数の値をまとめて扱います。",
			"codeBlocks": [
				{
					"title": "配列（Array）",
					"code": "// 配列は複数の値を順番に格納するコレクション型\n// 配列の作成（文字列の配列）\nvar fruits = [\"りんご\", \"バナナ\", \"オレンジ\"]  // 果物の名前を格納\nlet numbers = [1, 2, 3, 4, 5]  // 数値の配列\n\n// インデックスを使って要素にアクセス（0から始まる）\nprint(fruits[0])  // 最初の要素（りんご）を出力\nprint(numbers[0]) // 最初の要素（1）を出力\n\n// 要素の追加（appendメソッドを使う）\nfruits.append(\"ぶどう\")  // 配列の末尾にぶどうを追加\nprint(fruits)  // 追加後の配列全体を出力\n\n// 要素数の取得（countプロパティ）\nprint(fruits.count)  // fruits配列の要素数を出力\nprint(numbers.count) // numbers配列の要素数を出力",
					"output": "りんご\n1\n[\"りんご\", \"バナナ\", \"オレンジ\", \"ぶどう\"]\n4\n5",
					"executable": true,
					"keywords": ["array", "list", "append", "count", "index", "リスト", "配列"]
				},
				{
					"title": "辞書（Dictionary）",
					"code": "// 辞書はキーと値のペアを格納するコレクション型\n// 辞書の作成（キーが科目名、値が点数の辞書）\nvar scores = [\"数学\": 85, \"英語\": 92, \"国語\": 78]\n\n// キーを使って値を取得（オプショナルバインディングを使用）\nif let mathScore = scores[\"数学\"] {  // 数学の点数を取得しようとする\n    print(\"数学の点数: \\(mathScore)\")  // 取得成功したら出力\n}\n\n// 値の更新または追加\nscores[\"理科\"] = 88  // 理科の点数を追加\nprint(scores)  // 更新後の辞書全体を出力",
					"output": "数学の点数: 85\n[\"数学\": 85, \"英語\": 92, \"国語\": 78, \"理科\": 88]",
					"executable": true,
					"keywords": ["dictionary", "key", "value", "map", "hash", "連想配列", "辞書"]
				},
				{
					"title": "データの並べ替え（sorted）",
					"code": "// sorted()を使うと、配列の中身を特定のルールで並べ替えることができます\nlet numbers = [5, 2, 8, 1, 9]\n\n// 1. 基本的な並べ替え（小さい順）\nlet sortedNumbers = numbers.sorted()\nprint(\"小さい順: \\(sortedNumbers)\")\n\n// 2. 特殊な条件での並べ替え（大きい順など）\n// { $0 > $1 } は「前の要素($0)が後ろの要素($1)より大きいか」を比べるという意味です\nlet highToLow = numbers.sorted { $0 > $1 }\nprint(\"大きい順: \\(highToLow)\")\n\n// 3. 文字列の並べ替え（あいうえお順/アルファベット順）\nlet fruits = [\"みかん\", \"りんご\", \"ばなな\"]\nlet sortedFruits = fruits.sorted()\nprint(\"あいうえお順: \\(sortedFruits)\")",
					"output": "小さい順: [1, 2, 5, 8, 9]\\n大きい順: [9, 8, 5, 2, 1]\\nあいうえお順: [\"ばなな\", \"みかん\", \"りんご\"]",
					"executable": true,
					"keywords": ["sort", "order", "arrange", "sequence", "並べ替え", "ソート", "順番"]
				}
			]
		},
		{
			"id": "classes-structs",
			"title": "クラスと構造体",
			"description": "データをまとめて扱うための型です。",
			"codeBlocks": [
				{
					"title": "構造体の定義",
					"code": "// structキーワードを使って構造体を定義（関連するデータをまとめる）\nstruct Student {  // 学生を表す構造体\n    var name: String   // 名前（変数）\n    var age: Int       // 年齢（変数）\n    var grade: String  // 学年（変数）\n}\n\n// 構造体のインスタンスを作成\nvar student1 = Student(name: \"太郎\", age: 13, grade: \"中学1年\")\n\n// ドット記法を使ってプロパティにアクセス\nprint(\"\\(student1.name)は\\(student1.age)歳です\")",
					"output": "太郎は13歳です",
					"executable": true,
					"keywords": [
						"struct",
						"definition",
						"instance",
						"class",
						"model",
						"構造体",
						"インスタンス"
					]
				},
				{
					"title": "private（アクセス制御）",
					"code": "// privateキーワードはプロパティやメソッドを「外部からアクセス不可」にします\n// プロパティを隠すことで、意図しない変更を防ぎ、カプセル化を実現します\n\n// === 基本的な使い方 ===\n\nstruct BankAccount {\n    private var balance = 0      // 残高はprivate（外部からアクセス不可）\n    let accountHolder = \"太郎\"   // 名義人は外部からアクセス可能（privateなし）\n    \n    // 外部から呼べるメソッド\n    mutating func deposit(amount: Int) {\n        if amount > 0 {\n            balance += amount  // privateなプロパティには内部からアクセス可\n            print(\"\\(amount)円を入金しました\")\n        }\n    }\n    \n    mutating func withdraw(amount: Int) {\n        if amount <= balance {\n            balance -= amount\n            print(\"\\(amount)円を出金しました\")\n        } else {\n            print(\"残高不足です\")\n        }\n    }\n    \n    // 残高を確認するメソッド\n    func checkBalance() -> Int {\n        return balance\n    }\n}\n\n// 使用例\nvar myAccount = BankAccount(accountHolder: \"太郎\")\nmyAccount.deposit(amount: 10000)  // 入金は外部から呼べる\nprint(\"残高: \\(myAccount.checkBalance())\")  // 残高確認も外部から呼べる\n\n// myAccount.balance = 999999  // ❌ エラー: privateなのでアクセス不可\n// myAccount.balance を直接変更しようとするとコンパイルエラー\n\n// === privateなメソッドの例 ===\n\nclass Calculator {\n    private func privateHelp() -> String {\n        return \"これは内部処理に使うメソッドです\"\n    }\n    \n    func publicCalculate(a: Int, b: Int) -> Int {\n        // privateなメソッドは外部からは呼べないが、クラス内からは呼べる\n        print(privateHelp()) // 内部から呼び出し可能\n        return a + b\n    }\n}\n\nlet calc = Calculator()\nprint(calc.publicCalculate(a: 5, b: 3))  // ✅ 外部から呼べる\n// calc.privateHelp()  // ❌ エラー: privateなので呼べない\n\n// === private vs その他のアクセス制御 ===\n\nstruct Example {\n    var publicProperty = \"アクセス可能\"        // private なし（デフォルト）\n    private var privateProperty = \"アクセス不可\"   // private（このファイル内のみ使用可）\n    \n    // 比較:\n    // public（明示的）: 他のモジュールからもアクセス可能\n    // internal（デフォルト）: 同じモジュール内ならアクセス可能\n    // private: 同じ名前空間（struct, class内）のみアクセス可能\n}\n\n// === privateの活用例：データの保護 ===\n\nstruct Password {\n    private var password = \"\"  // パスワードを隠す\n    \n    mutating func setPassword(_ newPassword: String) {\n        // パスワードを直接設定する代わりに、バリデーションを行える\n        if newPassword.count >= 8 {\n            password = newPassword\n            print(\"パスワードを設定しました\")\n        } else {\n            print(\"パスワードは8文字以上である必要があります\")\n        }\n    }\n    \n    func isCorrect(_ input: String) -> Bool {\n        return input == password\n    }\n}\n\nvar userPassword = Password()\nuserPassword.setPassword(\"MySecure123\")  // バリデーション付きで設定\n// userPassword.password = \"123\"  // ❌ エラー: 直接変更できない\n\n// まとめ:\n// privateを使うメリット:\n// - データの不正な変更を防ぐ\n// - 内部実装を隠して、外部インターフェースを明確にする\n// - バリデーションなどの処理を強制できる",
					"output": "1\n10000円を入金しました\n残高: 10000\n5\n0\nパスワードを設定しました",
					"executable": true,
					"keywords": [
						"private",
						"access control",
						"encapsulation",
						"アクセス制御",
						"カプセル化",
						"隠す"
					]
				},
				{
					"title": "final（継承・オーバーライドの禁止）",
					"code": "// finalキーワードは、クラスの継承やメソッドのオーバーライドを禁止します\n// 「これ以上変更させたくない」ときに使います\n\n// === finalクラス：継承できないクラス ===\n\nfinal class MathHelper {\n    func add(_ a: Int, _ b: Int) -> Int {\n        return a + b\n    }\n    \n    func multiply(_ a: Int, _ b: Int) -> Int {\n        return a * b\n    }\n}\n\nlet math = MathHelper()\nprint(\"足し算: \\(math.add(3, 5))\")\nprint(\"掛け算: \\(math.multiply(4, 6))\")\n\n// ❌ 以下はコンパイルエラー（finalクラスは継承できない）\n// class AdvancedMath: MathHelper { }  // error: inheritance from a final class 'MathHelper'\n\n// === finalメソッド：オーバーライドできないメソッド ===\n\nclass Animal {\n    // このメソッドはサブクラスでオーバーライドできない\n    final func breathe() {\n        print(\"呼吸する\")\n    }\n    \n    // このメソッドはオーバーライドできる\n    func speak() {\n        print(\"...\")\n    }\n}\n\nclass Dog: Animal {\n    // ✅ speak()はオーバーライドできる\n    override func speak() {\n        print(\"ワンワン！\")\n    }\n    \n    // ❌ breathe()はfinalなのでオーバーライドできない\n    // override func breathe() { }  // error: instance method overrides a 'final' instance method\n}\n\nlet dog = Dog()\ndog.breathe()  // 親クラスのメソッドがそのまま使われる\ndog.speak()    // オーバーライドされたメソッドが呼ばれる\n\n// === finalプロパティ ===\n\nclass Vehicle {\n    final var wheels: Int  // サブクラスでオーバーライドできないプロパティ\n    var color: String      // オーバーライド可能なプロパティ\n    \n    init(wheels: Int, color: String) {\n        self.wheels = wheels\n        self.color = color\n    }\n}\n\nlet car = Vehicle(wheels: 4, color: \"赤\")\nprint(\"\\(car.color)い車、タイヤ\\(car.wheels)本\")\n\n// まとめ:\n// final class  → そのクラスを継承できない\n// final func   → そのメソッドをオーバーライドできない\n// final var    → そのプロパティをオーバーライドできない\n// finalを使うメリット:\n// - 意図しない変更を防ぐ（安全性の向上）\n// - コンパイラが最適化しやすくなる（パフォーマンス向上）",
					"output": "足し算: 8\n掛け算: 24\n呼吸する\nワンワン！\n赤い車、タイヤ4本",
					"executable": true,
					"keywords": [
						"final",
						"inheritance",
						"override",
						"class",
						"prevent",
						"継承",
						"オーバーライド",
						"禁止",
						"ファイナル"
					]
				}
			]
		},
		{
			"id": "methods",
			"title": "メソッド",
			"description": "メソッドは、特定の型（クラス、構造体、列挙型）の内部で定義された関数です。その型のデータ（プロパティ）を使って処理を行う「振る舞い」を定義します。",
			"codeBlocks": [
				{
					"title": "メソッドの定義と使用",
					"code": "class Counter {\n    var count = 0\n    \n    // カウントを1増やすメソッド\n    func increment() {\n        count += 1\n        print(\"カウント: \\(count)\")\n    }\n    \n    // 指定した数だけ増やすメソッド\n    func increment(by amount: Int) {\n        count += amount\n        print(\"\\(amount)増やしました。合計: \\(count)\")\n    }\n}\n\n// クラスのインスタンスを作成\nlet myCounter = Counter()\n\n// メソッドの呼び出し\nmyCounter.increment()\nmyCounter.increment(by: 5)",
					"output": "カウント: 1\n5増やしました。合計: 6",
					"executable": true,
					"keywords": [
						"method",
						"function",
						"class",
						"instance",
						"behavior",
						"振る舞い",
						"メソッド"
					]
				}
			],
			"afterHtml": "<div class=\"mt-8\"><h3 class=\"mb-4 text-xl font-bold\">関数とメソッドの違い</h3><div class=\"overflow-x-auto\"><table class=\"table w-full rounded-box table-zebra bg-base-200\"><thead><tr class=\"bg-base-300\"><th class=\"text-base text-base-content\">項目</th><th class=\"text-base text-base-content\">関数 (Function)</th><th class=\"text-base text-base-content\">メソッド (Method)</th></tr></thead><tbody><tr><td class=\"font-bold\">定義場所</td><td>型の外側（グローバル）</td><td>型（クラス・構造体）の内側</td></tr><tr><td class=\"font-bold\">呼び出し方</td><td><code class=\"rounded bg-base-300 px-1\">funcName()</code></td><td><code class=\"rounded bg-base-300 px-1\">instance.methodName()</code></td></tr><tr><td class=\"font-bold\">役割</td><td>単独で動作する処理のまとまり</td><td>その型のデータ操作や振る舞い</td></tr><tr><td class=\"font-bold\">データアクセス</td><td>引数のみ</td><td>インスタンス自身のプロパティ（<code>self</code>）にアクセス可能</td></tr></tbody></table></div></div>"
		},
		{
			"id": "keypaths",
			"title": "KeyPathと.self",
			"description": "\\（バックスラッシュ）はSwift独自のKeyPathリテラル記号で、プロパティへの参照や値そのものを指すために使います。@Environment(\\.colorScheme)やForEach(items, id: \\.self)など、SwiftUI全体で頻出します。",
			"codeBlocks": [
				{
					"title": "KeyPathと.selfの使い方",
					"code": "// 1. \\.self の意味\n// \\.self は「その値自身」を指すKeyPathです\nlet numbers = [10, 20, 30]\n\n// List(numbers, id: \\.self) のように使う場合、\n// 「配列の各要素（数値）そのものを識別子(ID)として使う」という意味になります\n\n\n// 2. プロパティへのKeyPath\nstruct Student {\n    var name: String\n    var grade: Int\n}\n\nlet students = [\n    Student(name: \"太郎\", grade: 1),\n    Student(name: \"花子\", grade: 2),\n    Student(name: \"次郎\", grade: 1)\n]\n\n// map関数などでKeyPathを使うと、クロージャを省略して簡潔に書けます\n// 通常の書き方: students.map { student in student.name }\nlet names = students.map(\\.name)\nprint(\"名前一覧: \\(names)\")\n\n// filterなどでの活用（KeyPathそのものではなく、プロパティ参照として）\n// KeyPath自体は値への「パス」を表す型です\nlet namePath = \\Student.name\nlet taro = students[0]\nprint(\"KeyPathでアクセス: \\(taro[keyPath: namePath])\")",
					"output": "names: [\"太郎\", \"花子\", \"次郎\"]\nKeyPathでアクセス: 太郎",
					"executable": true,
					"keywords": ["keypath", "self", "syntax", "reference", "参照", "キーパス", "\\."]
				}
			]
		},
		{
			"id": "optionals-error-handling",
			"title": "オプションとエラー処理",
			"description": "値が存在しない可能性を扱います。Swiftでは他の言語のnullの代わりにnilを使います。",
			"codeBlocks": [
				{
					"title": "Optional型",
					"code": "// Optional型は値が存在しない可能性を表す（型名の後に?をつける）\nvar optionalName: String? = \"太郎\"  // 値があるOptional\nvar optionalAge: Int? = nil         // nil（値なし）のOptional\n\n// オプショナルバインディング（if let）で安全に値を取り出す\nif let name = optionalName {  // optionalNameに値があればnameに代入\n    print(\"名前: \\(name)\")\n} else {\n    print(\"名前が設定されていません\")\n}\n\n// nilの値に対するオプショナルバインディング\nif let age = optionalAge {  // optionalAgeはnilなので実行されない\n    print(\"年齢: \\(age)\")\n} else {\n    print(\"年齢が設定されていません\")\n}\n\n// 強制アンラップ（!）はnilでないことを確認してから使用（危険）\nif optionalAge != nil {\n    print(\"年齢: \\(optionalAge!)\")  // !で強制的に値を取り出す\n}\n\n// 注意: nilに対して強制アンラップするとランタイムエラーになる\n// 以下のコードは実行しないこと（コメントアウト）\n// let nilValue: Int? = nil\n// print(nilValue!)  // Fatal error: Unexpectedly found nil while unwrapping an Optional value",
					"output": "名前: 太郎\n年齢が設定されていません",
					"executable": true,
					"keywords": [
						"nil",
						"unwrap",
						"binding",
						"if let",
						"guard",
						"?",
						"!",
						"アンラップ",
						"オプショナル"
					]
				},
				{
					"title": "do-catchと\\(error) - エラー処理",
					"code": "// do-catch文を使ってエラーを処理する\n// catchブロック内では、暗黙の変数「error」でエラー情報にアクセスできる\n\n// === エラー型の定義 ===\n\nenum ValidationError: Error {\n    case tooShort       // 短すぎる\n    case tooLong        // 長すぎる\n    case invalidFormat  // 形式が不正\n}\n\n// === throwsを使うエラーを投げる関数 ===\n\nfunc validateUsername(_ name: String) throws -> String {\n    if name.count < 3 {\n        throw ValidationError.tooShort\n    }\n    if name.count > 20 {\n        throw ValidationError.tooLong\n    }\n    return name\n}\n\n// === do-catchでエラーを受け取る ===\n\n// 成功するケース\ndo {\n    let validName = try validateUsername(\"太郎\")\n    print(\"ユーザー名: \\(validName)\")\n} catch {\n    // catchブロック内では「error」が自動的に使える\n    // \\(error) で文字列補間してエラー内容を表示\n    print(\"エラーが発生: \\(error)\")\n}\n\n// 失敗するケース\ndo {\n    let invalidName = try validateUsername(\"ab\")\n    print(\"ユーザー名: \\(invalidName)\")\n} catch {\n    // \\(error) はエラーの説明を文字列として埋め込む\n    print(\"エラーが発生: \\(error)\")  // \"エラーが発生: tooShort\"\n}\n\n// === エラーの種類ごとに処理を分ける ===\n\ndo {\n    let name = try validateUsername(\"ab\")\n    print(name)\n} catch ValidationError.tooShort {\n    print(\"ユーザー名が短すぎます（3文字以上必要）\")\n} catch ValidationError.tooLong {\n    print(\"ユーザー名が長すぎます（20文字以下にしてください）\")\n} catch {\n    // その他のエラーをキャッチ\n    // ここでも \\(error) が使える\n    print(\"予期しないエラー: \\(error)\")\n}\n\n// === \\(error) の仕組み ===\n\n// catch { } ブロック内では、Swiftが自動的に「error」という\n// 変数を提供します（明示的に名前をつける必要がない）\n// \\(error) は文字列補間で、エラーの説明文を埋め込みます\n\n// 明示的に名前をつけることも可能\ndo {\n    let name = try validateUsername(\"ab\")\n    print(name)\n} catch let myError {  // errorの代わりにmyErrorという名前で受け取る\n    print(\"カスタム名でキャッチ: \\(myError)\")\n}",
					"output": "ユーザー名: 太郎\nエラーが発生: tooShort\nユーザー名が短すぎます（3文字以上必要）\nカスタム名でキャッチ: tooShort",
					"executable": true,
					"keywords": [
						"error",
						"do",
						"catch",
						"try",
						"throw",
						"throws",
						"\\(error)",
						"エラー処理",
						"例外",
						"エラーハンドリング"
					]
				},
				{
					"title": "try、try?、try! の使い分け",
					"code": "// throws関数でエラーが発生する可能性がある関数を定義\nenum FileError: Error {\n    case fileNotFound\n    case permissionDenied\n    case unknownError\n}\n\nfunc readFile(name: String) throws -> String {\n    if name.isEmpty {\n        throw FileError.fileNotFound  // エラーを投げる\n    }\n    return \"ファイルの内容: \\(name)\"\n}\n\n// === try: エラーをキャッチして処理する（推奨） ===\n// do-catch内で使い、エラーが発生した場合の処理を書く\nprint(\"--- try の使用例 ---\")\ndo {\n    let content = try readFile(name: \"data.txt\")\n    print(content)\n} catch FileError.fileNotFound {\n    print(\"ファイルが見つかりません\")\n} catch FileError.permissionDenied {\n    print(\"ファイルへのアクセス権がありません\")\n} catch {\n    print(\"予期しないエラー: \\(error)\")\n}\n\n// === try?: エラーを無視してnil を返す ===\n// エラーが発生した場合、値の代わりに nil が返される\n// 結果はOptional型（型?)になる\nprint(\"\\n--- try? の使用例 ---\")\nif let content = try? readFile(name: \"data.txt\") {\n    print(content)  // 成功時に実行\n} else {\n    print(\"ファイルの読み込みに失敗しました\")\n}\n\n// try?は結果がOptionalになるので、if letで扱うことが多い\nlet result = try? readFile(name: \"missing.txt\")\nprint(\"結果: \\(result ?? \\\"nil (エラー発生)\\\")\")  // nil (エラー発生)\n\n// === try!: エラーが発生しないと確信するときに使う（危険） ===\n// エラーが発生すると、アプリがクラッシュする\n// 絶対に エラーが発生しないと確信できる場合だけ使用\nprint(\"\\n--- try! の使用例 ---\")\nlet safeContent = try! readFile(name: \"config.txt\")\nprint(safeContent)\n\n// 注意: 以下のコードはエラーが発生してクラッシュしてしまう\n// let crash = try! readFile(name: \"\")  // ← fatal error になる\n\n// === 使い分けの比較 ===\nprint(\"\\n--- 使い分けのまとめ ---\")\nprint(\"try:   エラーの種類に応じて処理を分ける（推奨）\")\nprint(\"try?:  エラーは無視して、成功/失敗だけを判定\")\nprint(\"try!:  エラーは絶対発生しないと確信できる場合のみ\")  \nprint(\"       （使うべき場面は限定的、できるだけ避ける）\")",
					"output": "--- try の使用例 ---\nファイルが見つかりません\n\n--- try? の使用例 ---\nファイルの読み込みに失敗しました\n結果: nil (エラー発生)\n\n--- try! の使用例 ---\nファイルの内容: config.txt\n\n--- 使い分けのまとめ ---\ntry:   エラーの種類に応じて処理を分ける（推奨）\ntry?:  エラーは無視して、成功/失敗だけを判定\ntry!:  エラーは絶対発生しないと確信できる場合のみ\n       （使うべき場面は限定的、できるだけ避ける）",
					"executable": true,
					"keywords": [
						"try",
						"try?",
						"try!",
						"error",
						"throws",
						"do-catch",
						"optional",
						"強制",
						"エラーハンドリング",
						"例外処理"
					]
				}
			]
		},
		{
			"id": "useful-functions",
			"title": "便利な関数",
			"description": "よく使う組み込み関数です。",
			"codeBlocks": [
				{
					"title": "print関数",
					"code": "// print関数はコンソールに値を出力する\nprint(\"Hello, World!\")  // 基本的な出力\nprint(\"名前: 太郎, 年齢: 13\")  // 複数の値をカンマ区切りで出力\n\n// terminatorパラメータで改行を制御（デフォルトは\\n）\nprint(\"こんにちは\", terminator: \"\")  // 改行なしで出力\n\n// 明示的に改行を指定（デフォルトと同じ）\nprint(\"こんにちは\", terminator: \"\\n\")\n\n// 複数の改行を出力\nprint(\"1行目\")  // 1行目出力\nprint(\"2行目\", terminator: \"\\n\\n\")  // 2行目出力後に2回改行\nprint(\"4行目\")  // 4行目出力",
					"output": "Hello, World!\n名前: 太郎, 年齢: 13\nこんにちはこんにちは\n1行目\n2行目\n\n4行目",
					"executable": true,
					"keywords": ["log", "console", "debug", "output", "出力", "プリント"]
				},
				{
					"title": "Stringのメソッド",
					"code": "let message = \"Hello, Swift!\"  // 文字列を変数に代入\n\n// countプロパティで文字数を取得\nprint(message.count)  // 文字列の長さ（文字数）を出力\n\n// uppercased()メソッドで大文字に変換\nprint(message.uppercased())  // \"HELLO, SWIFT!\"\n\n// lowercased()メソッドで小文字に変換\nprint(message.lowercased())  // \"hello, swift!\"\n\n// contains()メソッドで部分文字列の検索\nif message.contains(\"Swift\") {  // \"Swift\"が含まれているかチェック\n    print(\"Swiftが見つかりました\")  // 含まれていれば出力\n}",
					"output": "13\nHELLO, SWIFT!\nhello, swift!\nSwiftが見つかりました",
					"executable": true,
					"keywords": [
						"length",
						"count",
						"upper",
						"lower",
						"search",
						"contains",
						"文字数",
						"検索",
						"大文字",
						"小文字"
					]
				},
				{
					"title": "UUID() - 一意なIDの生成",
					"code": "import Foundation\n\n// UUID（Universally Unique Identifier）は、世界で唯一の識別子を生成します\n// ランダムなUUIDを生成\nlet id = UUID()\nprint(\"生成されたID: \\(id)\")\n// 出力例: E621E1F8-C36C-495A-93FC-0C247A3E6E5F\n\n// 文字列として取得する場合\nlet idString = id.uuidString\nprint(\"文字列形式: \\(idString)\")\n\n// SwiftUIでの活用例（リスト表示の識別子としてよく使われます）\nstruct TodoItem: Identifiable {\n    let id = UUID()  // インスタンス作成時に自動でユニークなIDを付与\n    var title: String\n}\n\nlet item = TodoItem(title: \"牛乳を買う\")\nprint(\"Todo項目のID: \\(item.id)\")",
					"output": "生成されたID: E621E1F8-C36C-495A-93FC-0C247A3E6E5F\n文字列形式: E621E1F8-C36C-495A-93FC-0C247A3E6E5F\nTodo項目のID: E621E1F8-C36C-495A-93FC-0C247A3E6E5F",
					"executable": true,
					"keywords": ["id", "unique", "identifier", "random", "uuid", "識別子", "一意", "ランダム"]
				}
			]
		},
		{
			"id": "swiftui-property-wrappers",
			"title": "SwiftUIプロパティラッパー",
			"description": "ビューの状態管理とデータの受け渡しに使う特別な属性です。",
			"codeBlocks": [
				{
					"title": "@State（状態の管理）",
					"code": "import SwiftUI\n\n// @Stateは、ビュー内で変更可能な状態を管理するためのプロパティラッパーです\n// 値が変更されると、ビューが自動的に再描画されます\n\nstruct CounterView: View {\n    // @Stateを使って、カウント値を管理\n    // privateをつけるのが推奨（このビュー内でのみ使用するため）\n    @State private var count = 0\n    \n    var body: some View {\n        VStack {\n            Text(\"カウント: \\(count)\")\n            \n            Button(\"増やす\") {\n                count += 1  // 値を変更するとビューが更新される\n            }\n        }\n    }\n}\n\n// @Stateの特徴:\n// - ビューが所有する「単一の情報源」\n// - 値型（Int, String, Bool, 構造体など）に使用\n// - ビューが再生成されても値は保持される",
					"output": "（ボタンを押すたびにカウントが1ずつ増える）",
					"executable": false,
					"keywords": ["state", "property wrapper", "view", "update", "状態", "再描画"]
				},
				{
					"title": "@Binding（双方向データ渡し）",
					"code": "import SwiftUI\n\n// @Bindingは、親ビューの@State変数への「参照」を子ビューに渡すためのプロパティラッパーです\n// 子ビューで値を変更すると、親ビューの値も変更されます\n\n// 子ビュー: トグルスイッチのコンポーネント\nstruct ToggleRow: View {\n    let label: String\n    @Binding var isOn: Bool  // 親からの参照を受け取る\n    \n    var body: some View {\n        Toggle(label, isOn: $isOn)  // $をつけてBindingとして渡す\n    }\n}\n\n// 親ビュー\nstruct SettingsView: View {\n    @State private var notificationsEnabled = true  // 親が所有する状態\n    @State private var darkModeEnabled = false\n    \n    var body: some View {\n        VStack {\n            // 子ビューに$をつけてBindingとして渡す\n            ToggleRow(label: \"通知\", isOn: $notificationsEnabled)\n            ToggleRow(label: \"ダークモード\", isOn: $darkModeEnabled)\n            \n            // 現在の状態を表示\n            Text(\"通知: \\(notificationsEnabled ? \"ON\" : \"OFF\")\")\n            Text(\"ダークモード: \\(darkModeEnabled ? \"ON\" : \"OFF\")\")\n        }\n    }\n}",
					"output": "（子ビューでトグルを切り替えると、親ビューの状態も更新される）",
					"executable": false,
					"keywords": [
						"binding",
						"share",
						"reference",
						"two-way",
						"双方向",
						"参照",
						"バインディング"
					]
				},
				{
					"title": "@Stateと@Bindingの使い分け",
					"code": "import SwiftUI\n\n// TextFieldの例で@Stateと@Bindingの連携を理解する\n\n// 入力フォームの子コンポーネント\nstruct NameInputField: View {\n    @Binding var name: String  // 親から渡される参照\n    \n    var body: some View {\n        TextField(\"名前を入力\", text: $name)\n            .textFieldStyle(.roundedBorder)\n    }\n}\n\n// 親ビュー\nstruct FormView: View {\n    @State private var userName = \"\"  // この状態を親が「所有」\n    \n    var body: some View {\n        VStack(spacing: 20) {\n            // 子ビューに状態の「参照」を渡す\n            NameInputField(name: $userName)\n            \n            // 入力された値をリアルタイムで表示\n            Text(\"こんにちは、\\(userName.isEmpty ? \"ゲスト\" : userName)さん！\")\n        }\n        .padding()\n    }\n}\n\n// まとめ:\n// @State  → 「状態を持つ」側（親）で使う\n// @Binding → 「状態を借りる」側（子）で使う\n// $変数名 → Bindingとして渡すときに使う記法",
					"output": "（TextFieldに入力すると、下のテキストがリアルタイムで更新される）",
					"executable": false,
					"keywords": ["difference", "usage", "pattern", "使い分け", "違い"]
				},
				{
					"title": "@FocusState（フォーカス管理）",
					"code": "import SwiftUI\n\n// @FocusStateは、どのTextFieldやSecureFieldがフォーカスを持つかを管理するプロパティラッパーです\n// iOS 15以降で利用可能です\n\n// === 基本的な使い方（単一フィールド） ===\n\nstruct SearchView: View {\n    @State private var searchText = \"\"\n    @FocusState private var isSearchFocused: Bool  // フォーカス状態を管理\n    \n    var body: some View {\n        VStack {\n            TextField(\"検索\", text: $searchText)\n                .textFieldStyle(.roundedBorder)\n                .focused($isSearchFocused)  // このフィールドがフォーカスを持つ\n            \n            // フォーカス状態に応じて表示を変える\n            if isSearchFocused {\n                Text(\"検索モード中...\")\n                    .foregroundStyle(.blue)\n            }\n        }\n        .padding()\n    }\n}\n\n// === 複数フィールドのフォーカス管理（Enum を使用） ===\n\nstruct LoginForm: View {\n    @State private var email = \"\"\n    @State private var password = \"\"\n    \n    // 列挙型でフォーカス状態を管理（複数フィールドの場合）\n    enum FocusField {\n        case email       // メールフィールド\n        case password    // パスワードフィールド\n    }\n    \n    @FocusState private var focusedField: FocusField?\n    \n    var body: some View {\n        VStack(spacing: 16) {\n            // メールフィールド\n            TextField(\"メールアドレス\", text: $email)\n                .textFieldStyle(.roundedBorder)\n                .focused($focusedField, equals: .email)  // このフィールドがfocusedField == .emailの時にフォーカス\n            \n            // パスワードフィールド\n            SecureField(\"パスワード\", text: $password)\n                .textFieldStyle(.roundedBorder)\n                .focused($focusedField, equals: .password)  // このフィールドがfocusedField == .passwordの時にフォーカス\n            \n            // 現在のフォーカス状態を表示\n            Text(\"フォーカス中: \\(focusedField == .email ? \"メール\" : focusedField == .password ? \"パスワード\" : \"なし\")\")\n                .font(.caption)\n                .foregroundStyle(.secondary)\n        }\n        .padding()\n    }\n}\n\n// === フォーカスを自動的に移動する ===\n\nstruct AutoFocusForm: View {\n    @State private var firstName = \"\"\n    @State private var lastName = \"\"\n    \n    enum FocusField {\n        case firstName\n        case lastName\n    }\n    \n    @FocusState private var focusedField: FocusField?\n    \n    var body: some View {\n        VStack(spacing: 16) {\n            TextField(\"名前\", text: $firstName)\n                .textFieldStyle(.roundedBorder)\n                .focused($focusedField, equals: .firstName)\n                .onChange(of: firstName) { _, newValue in\n                    // 名前が入力されたら自動的にパスワードフィールドに移動\n                    if newValue.count > 0 {\n                        focusedField = .lastName\n                    }\n                }\n            \n            TextField(\"苗字\", text: $lastName)\n                .textFieldStyle(.roundedBorder)\n                .focused($focusedField, equals: .lastName)\n        }\n        .padding()\n        .onAppear {\n            // 画面表示時に最初のフィールドにフォーカスを設定\n            focusedField = .firstName\n        }\n    }\n}\n\n// === キーボード操作でフォーカスを制御 ===\n\nstruct KeyboardDismiss: View {\n    @State private var text = \"\"\n    @FocusState private var isFocused: Bool\n    \n    var body: some View {\n        VStack {\n            TextField(\"入力してください\", text: $text)\n                .textFieldStyle(.roundedBorder)\n                .focused($isFocused)\n            \n            Button(action: {\n                isFocused = false  // フォーカスを外す（キーボード閉じる）\n                text = \"\"  // テキストをクリア\n            }) {\n                Text(\"クリア\")\n                    .frame(maxWidth: .infinity)\n                    .padding()\n                    .background(.blue)\n                    .foregroundStyle(.white)\n                    .cornerRadius(8)\n            }\n        }\n        .padding()\n    }\n}",
					"output": "（テキストフィールドをタップするとフォーカス状態が変わり、キーボードが表示される）",
					"executable": false,
					"keywords": [
						"focus",
						"textfield",
						"keyboard",
						"input",
						"フォーカス",
						"入力欄",
						"キーボード"
					]
				},
				{
					"title": "@Environment（環境値の取得）",
					"code": "import SwiftUI\n\n// @Environmentは、SwiftUIが提供する「環境値」を読み取るためのプロパティラッパーです\n// システム設定やアプリ全体で共有される値にアクセスできます\n\n// === 基本的な使い方 ===\n\nstruct ThemeView: View {\n    // システムのカラースキーム（ライト/ダーク）を取得\n    @Environment(\\.colorScheme) var colorScheme\n    \n    var body: some View {\n        VStack {\n            Text(\"現在のモード\")\n                .font(.headline)\n            \n            if colorScheme == .dark {\n                Text(\"ダークモードです\")\n                    .foregroundStyle(.white)\n            } else {\n                Text(\"ライトモードです\")\n                    .foregroundStyle(.black)\n            }\n        }\n    }\n}\n\n// === よく使う環境値 ===\n\nstruct EnvironmentExamplesView: View {\n    @Environment(\\.colorScheme) var colorScheme        // ライト/ダークモード\n    @Environment(\\.locale) var locale                  // 言語・地域設定\n    @Environment(\\.horizontalSizeClass) var sizeClass  // 画面サイズ（iPhone/iPad判定）\n    \n    var body: some View {\n        VStack(spacing: 12) {\n            Text(\"カラースキーム: \\(colorScheme == .dark ? \"ダーク\" : \"ライト\")\")\n            Text(\"言語: \\(locale.language.languageCode?.identifier ?? \"不明\")\")\n            Text(\"サイズ: \\(sizeClass == .compact ? \"コンパクト\" : \"レギュラー\")\")\n        }\n    }\n}\n\n// === dismiss（画面を閉じる） ===\n\nstruct DetailView: View {\n    // 画面を閉じるためのアクションを取得\n    @Environment(\\.dismiss) var dismiss\n    \n    var body: some View {\n        VStack {\n            Text(\"詳細画面\")\n                .font(.title)\n            \n            Button(\"閉じる\") {\n                dismiss()  // この画面を閉じる\n            }\n        }\n    }\n}\n\n// 使用例: sheetで表示した画面を閉じる\nstruct ParentView: View {\n    @State private var showDetail = false\n    \n    var body: some View {\n        Button(\"詳細を表示\") {\n            showDetail = true\n        }\n        .sheet(isPresented: $showDetail) {\n            DetailView()  // DetailView内でdismiss()を呼ぶと閉じる\n        }\n    }\n}\n\n// === カスタム環境値を渡す ===\n\nstruct ChildView: View {\n    @Environment(\\.font) var font  // 親から渡されたフォントを取得\n    \n    var body: some View {\n        Text(\"このテキストは親のフォント設定を継承します\")\n    }\n}\n\nstruct CustomEnvView: View {\n    var body: some View {\n        VStack {\n            // .environment()モディファイアで子ビューに環境値を渡す\n            ChildView()\n                .environment(\\.font, .title)\n        }\n    }\n}\n\n// まとめ:\n// @Environment(\\.キー名) → システムや親から環境値を取得\n// .environment(\\.キー名, 値) → 子ビューに環境値を渡す\n// よく使うキー:\n//   \\.colorScheme → ライト/ダークモード\n//   \\.dismiss → 画面を閉じるアクション\n//   \\.locale → 言語・地域設定\n//   \\.font → フォント設定",
					"output": "（環境値に応じてビューの表示が変わる）",
					"executable": false,
					"keywords": [
						"environment",
						"colorScheme",
						"dismiss",
						"locale",
						"system",
						"環境",
						"ダークモード",
						"画面を閉じる",
						"環境値"
					]
				},
				{
					"title": "@ViewBuilder（複数ビューを組み合わせる）",
					"code": "import SwiftUI\n\n// @ViewBuilder を使うと複数のビューを 1 つの結果としてまとめられる\nstruct CustomColumn<Content: View>: View {\n    let content: () -> Content\n    \n    var body: some View {\n        VStack(spacing: 12) {\n            content()\n        }\n    }\n    \n    init(@ViewBuilder content: @escaping () -> Content) {\n        self.content = content\n    }\n}\n\n// @ViewBuilder の関数を定義すると、条件分岐でビューを増やせる\n@ViewBuilder\nfunc detailRows() -> some View {\n    Text(\"名前: 太郎\")\n    Text(\"学年: 中学1年\")\n    if Bool.random() {\n        Text(\"ランダムで表示される補足\")\n    }\n}\n\nstruct ViewBuilderExample: View {\n    var body: some View {\n        CustomColumn {\n            detailRows()\n            Text(\"この行も@ViewBuilderの中で追加\")\n        }\n    }\n}\n\n// ポイント:\n// - 複数の View を return できる\n// - if や switch で条件付きビューを返せる\n// - SwiftUI のクロージャでは暗黙的に使われている",
					"output": "（複数行が縦に並び、条件に応じたTextが表示される）",
					"executable": false,
					"keywords": [
						"viewbuilder",
						"result builder",
						"function builder",
						"conditional",
						"複数ビュー",
						"カスタム"
					]
				}
			],
			"afterHtml": "<div class=\"mt-8\"><h3 class=\"mb-4 text-xl font-bold\">@Stateと@Bindingの関係</h3><div class=\"overflow-x-auto\"><table class=\"table w-full rounded-box table-zebra bg-base-200\"><thead><tr class=\"bg-base-300\"><th class=\"text-base text-base-content\">項目</th><th class=\"text-base text-base-content\">@State</th><th class=\"text-base text-base-content\">@Binding</th></tr></thead><tbody><tr><td class=\"font-bold\">役割</td><td>状態を「所有」する</td><td>状態を「参照」する</td></tr><tr><td class=\"font-bold\">使う場所</td><td>親ビュー（状態の発生源）</td><td>子ビュー（状態を受け取る側）</td></tr><tr><td class=\"font-bold\">宣言方法</td><td><code class=\"rounded bg-base-300 px-1\">@State private var value = 初期値</code></td><td><code class=\"rounded bg-base-300 px-1\">@Binding var value: 型</code></td></tr><tr><td class=\"font-bold\">渡し方</td><td>-</td><td><code class=\"rounded bg-base-300 px-1\">$変数名</code>で渡す</td></tr><tr><td class=\"font-bold\">初期値</td><td>必要</td><td>不要（親から受け取る）</td></tr></tbody></table></div></div>"
		},
		{
			"id": "swiftui-foreach",
			"title": "ForEach（リスト構築）",
			"description": "複数のビューを効率よく生成するSwiftUIコンポーネントです。",
			"codeBlocks": [
				{
					"title": "ForEachの基本的な使い方",
					"code": "import SwiftUI\n\n// ForEachは配列の各要素に対して、ビューを繰り返し生成します\n\nstruct FruitListView: View {\n    // 果物の名前の配列\n    let fruits = [\"りんご\", \"バナナ\", \"オレンジ\"]\n    \n    var body: some View {\n        VStack {\n            // ForEachを使ってリストアイテムを生成\n            ForEach(fruits, id: \\.self) { fruit in\n                Text(fruit)  // 各果物の名前をTextで表示\n                    .font(.headline)\n                    .padding()\n            }\n        }\n    }\n}\n\n// ForEachの要素:\n// - fruits: 繰り返す配列\n// - id: \\.self: 各要素を識別するキー（ここでは値そのものをID として使用）\n// - fruit in: クロージャで各要素を受け取る\n// - { 処理 }: 各要素に対して実行するビューの定義",
					"output": "（同じリストアイテムが3行に分かれて表示される）",
					"executable": false,
					"keywords": [
						"foreach",
						"list",
						"iterate",
						"loop",
						"array",
						"ビュー生成",
						"ループ",
						"繰り返し"
					]
				},
				{
					"title": "id パラメータの役割",
					"code": "import SwiftUI\n\n// idパラメータは、各要素を一意に識別するための「キー」です\n// SwiftUIが「どの要素が変更されたか」を判定するために使われます\n\n// パターン1: 値型（String, Int）の場合はid: \\.self を使う\nstruct SimpleView: View {\n    let numbers = [1, 2, 3, 4, 5]\n    \n    var body: some View {\n        VStack {\n            ForEach(numbers, id: \\.self) { num in\n                Text(\"数字: \\(num)\")\n            }\n        }\n    }\n}\n\n// パターン2: 複雑な型（構造体）の場合は、Identifiable に準拠させる\nstruct Student: Identifiable {\n    let id = UUID()  // 各学生に一意なIDを付与\n    var name: String\n    var grade: Int\n}\n\nstruct StudentListView: View {\n    let students = [\n        Student(name: \"太郎\", grade: 1),\n        Student(name: \"花子\", grade: 1),\n        Student(name: \"次郎\", grade: 2)\n    ]\n    \n    var body: some View {\n        VStack {\n            // Identifiableに準拠しているので、idを省略できる\n            ForEach(students) { student in\n                HStack {\n                    Text(student.name)\n                    Text(\"\\(student.grade)年\")\n                        .foregroundStyle(.secondary)\n                }\n                .padding()\n            }\n        }\n    }\n}\n\n// パターン3: プロパティを明示的に指定\nstruct UserView: View {\n    let users = [\n        (id: 1, name: \"太郎\"),\n        (id: 2, name: \"花子\"),\n        (id: 3, name: \"次郎\")\n    ]\n    \n    var body: some View {\n        VStack {\n            ForEach(users, id: \\.id) { user in  // idプロパティをキーとして使用\n                Text(user.name)\n            }\n        }\n    }\n}",
					"output": "（各パターンで配列の要素がリストアイテムとして表示される）",
					"executable": false,
					"keywords": ["id", "key", "identifiable", "uuid", "識別子", "一意", "キー"]
				},
				{
					"title": "ForEachと@State の組み合わせ",
					"code": "import SwiftUI\n\n// ForEachで動的にリストを更新する例\n\nstruct TodoListView: View {\n    // Todoアイテムの構造体\n    struct TodoItem: Identifiable {\n        let id = UUID()\n        var title: String\n        var isCompleted: Bool = false\n    }\n    \n    // @Stateで状態を管理\n    @State private var todos: [TodoItem] = [\n        TodoItem(title: \"牛乳を買う\"),\n        TodoItem(title: \"数学の宿題\"),\n        TodoItem(title: \"部屋を片付ける\")\n    ]\n    \n    var body: some View {\n        VStack {\n            Text(\"やることリスト\")\n                .font(.title)\n            \n            // ForEachでリストの各要素をビューとして生成\n            ForEach($todos) { $todo in  // $をつけてBindingとして受け取る\n                HStack {\n                    // チェックボックスの役割\n                    Image(systemName: todo.isCompleted ? \"checkmark.circle.fill\" : \"circle\")\n                        .foregroundStyle(todo.isCompleted ? .green : .gray)\n                        .onTapGesture {\n                            todo.isCompleted.toggle()  // タップで完了状態を切り替え\n                        }\n                    \n                    Text(todo.title)\n                        .strikethrough(todo.isCompleted)  // 完了時は取り消し線を表示\n                    \n                    Spacer()  // スペースを挿入\n                }\n                .padding()\n            }\n            \n            Spacer()\n        }\n    }\n}\n\n// ポイント:\n// - $todosでBindingリストを取得\n// - ForEachの中で$todoでBinding値を受け取る\n// - Bindingを使うことで、子ビューでの変更が親の@Stateに反映される",
					"output": "（チェックマークをタップすると、アイテムが完了状態に切り替わる）",
					"executable": false,
					"keywords": ["dynamic", "update", "binding", "state", "todo", "list", "動的", "更新"]
				},
				{
					"title": "ForEachでList・ScrollViewと組み合わせ",
					"code": "import SwiftUI\n\n// List内でForEachを使う（最もよくあるパターン）\n\nstruct BookListView: View {\n    struct Book: Identifiable {\n        let id = UUID()\n        var title: String\n        var author: String\n        var year: Int\n    }\n    \n    let books = [\n        Book(title: \"吾輩は猫である\", author: \"夏目漱石\", year: 1905),\n        Book(title: \"羅生門\", author: \"芥川龍之介\", year: 1915),\n        Book(title: \"こころ\", author: \"夏目漱石\", year: 1914)\n    ]\n    \n    var body: some View {\n        VStack {\n            Text(\"古典文学\")\n                .font(.title2)\n            \n            // ListはForEachと相性が良い\n            List {\n                ForEach(books) { book in\n                    VStack(alignment: .leading, spacing: 4) {\n                        Text(book.title)\n                            .font(.headline)\n                        Text(book.author)\n                            .font(.caption)\n                            .foregroundStyle(.secondary)\n                        Text(\"\\(book.year)年\")\n                            .font(.caption2)\n                            .foregroundStyle(.secondary)\n                    }\n                    .padding(.vertical, 4)\n                }\n            }\n            .listStyle(.plain)\n        }\n    }\n}\n\n// ScrollViewと組み合わせ\nstruct ScrollableListView: View {\n    let items = Array(1...100).map { \"アイテム#\\($0)\" }\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: 10) {\n                ForEach(items, id: \\.self) { item in\n                    Text(item)\n                        .frame(maxWidth: .infinity, alignment: .leading)\n                        .padding()\n                        .background(Color(.systemGray6))\n                        .cornerRadius(8)\n                }\n            }\n            .padding()\n        }\n    }\n}",
					"output": "（リスト形式でアイテムが表示され、スクロール可能になる）",
					"executable": false,
					"keywords": [
						"list",
						"scrollview",
						"container",
						"grid",
						"layout",
						"リスト表示",
						"スクロール"
					]
				},
				{
					"title": "ForEachのベストプラクティス",
					"code": "import SwiftUI\n\n// よくある間違いと正しい使い方\n\n// ❌ 間違い: idを指定しない（警告が出る）\n// ForEach(items) { item in ... }  // 危険\n\n// ✅ 正しい: 適切なidを指定\nstruct GoodPracticeView: View {\n    struct Task: Identifiable {\n        let id: UUID\n        var name: String\n        var done: Bool\n    }\n    \n    @State private var tasks: [Task] = [\n        Task(id: UUID(), name: \"タスク1\", done: false),\n        Task(id: UUID(), name: \"タスク2\", done: true)\n    ]\n    \n    var body: some View {\n        VStack {\n            // ✅ Good: Identifiableに準拠しているので安全\n            ForEach(tasks) { task in\n                Text(task.name)\n            }\n            \n            // ✅ Good: id: \\.self で値を識別\n            ForEach([\"A\", \"B\", \"C\"], id: \\.self) { letter in\n                Text(letter)\n            }\n            \n            // ✅ Good: id: \\.id でプロパティを指定\n            ForEach(tasks, id: \\.id) { task in\n                Text(task.name)\n            }\n        }\n    }\n}\n\n// ベストプラクティス:\n// 1. 可能なら Identifiable に準拠させる（最も安全）\n// 2. UUIDやデータベースのidを使う（重複がない）\n// 3. 値型の場合は id: \\.self を使う\n// 4. idを明示的に指定して意図を明確にする",
					"output": "（各パターンが正しく機能する）",
					"executable": false,
					"keywords": [
						"best practice",
						"safe",
						"identifiable",
						"uuid",
						"pattern",
						"ベストプラクティス",
						"安全"
					]
				}
			]
		},
		{
			"id": "swiftui-identifiable",
			"title": "Identifiable（識別可能プロトコル）",
			"description": "ForEachやListで各要素を一意に識別するためのプロトコルです。データ型に `id` プロパティを自動的に提供します。",
			"codeBlocks": [
				{
					"title": "Identifiableの基本",
					"code": "import SwiftUI\n\n// Identifiableはプロトコルで、型に一意の識別子を持たせます\n// 次の2つが必要:\n// 1. Identifiable プロトコルに準拠\n// 2. id という名前のプロパティを定義\n\nstruct Student: Identifiable {\n    // id プロパティは、各インスタンスを一意に識別するために使われます\n    let id = UUID()  // UUIDは「世界で唯一の識別子」を生成\n    \n    // その他のプロパティ\n    var name: String\n    var grade: Int\n}\n\n// インスタンスを作成\nlet student1 = Student(name: \"太郎\", grade: 1)\nlet student2 = Student(name: \"花子\", grade: 1)\n\nprint(\"学生1のID: \\(student1.id)\")\nprint(\"学生2のID: \\(student2.id)\")\nprint(\"IDが異なる: \\(student1.id != student2.id)\")  // true\n\n// Identifiableに準拠するメリット:\n// - ForEachでid指定を省略できる\n// - List や TabView でも直接使える\n// - 各要素の変更を正確に追跡できる",
					"output": "学生1のID: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n学生2のID: YYYYYYYY-YYYY-YYYY-YYYY-YYYYYYYYYYYY\nIDが異なる: true",
					"executable": true,
					"keywords": ["identifiable", "protocol", "id", "unique", "識別", "プロトコル", "一意"]
				},
				{
					"title": "ForEachでIdentifiableを使う",
					"code": "import SwiftUI\n\nstruct Book: Identifiable {\n    let id = UUID()  // Identifiableに必須の id プロパティ\n    var title: String\n    var author: String\n}\n\nstruct BookListView: View {\n    let books = [\n        Book(title: \"吾輩は猫である\", author: \"夏目漱石\"),\n        Book(title: \"羅生門\", author: \"芥川龍之介\"),\n        Book(title: \"こころ\", author: \"夏目漱石\")\n    ]\n    \n    var body: some View {\n        VStack(spacing: 10) {\n            Text(\"本の一覧\")\n                .font(.title2)\n            \n            // ✅ Identifiableに準拠しているので、id:を省略できる\n            ForEach(books) { book in\n                VStack(alignment: .leading, spacing: 4) {\n                    Text(book.title)\n                        .font(.headline)\n                    Text(\"著者: \\(book.author)\")\n                        .font(.caption)\n                        .foregroundStyle(.secondary)\n                }\n                .frame(maxWidth: .infinity, alignment: .leading)\n                .padding()\n                .background(Color(.systemGray6))\n                .cornerRadius(8)\n            }\n        }\n        .padding()\n    }\n}\n\n// 比較:\n// ❌ Identifiableに準拠していない場合\n// ForEach(books, id: \\.id) { book in ... }  // idを明示的に指定\n\n// ✅ Identifiableに準拠した場合\n// ForEach(books) { book in ... }  // idを省略できて簡潔",
					"output": "（本のタイトルと著者がカード形式で表示される）",
					"executable": false,
					"keywords": ["foreach", "list", "efficient", "省略", "簡潔", "フォーエッチ"]
				},
				{
					"title": "数値IDでIdentifiableを実装",
					"code": "import SwiftUI\n\n// id プロパティの型は UUID でなく、Int など他の型でもOK\n// 必要なのは「一意である（重複しない）」ことだけです\n\nstruct User: Identifiable {\n    let id: Int  // 整数のIDを使う（例: データベースからのID）\n    var name: String\n    var email: String\n}\n\nstruct UserListView: View {\n    // データベースから取得したと想定\n    let users = [\n        User(id: 1, name: \"太郎\", email: \"taro@example.com\"),\n        User(id: 2, name: \"花子\", email: \"hanako@example.com\"),\n        User(id: 3, name: \"次郎\", email: \"jiro@example.com\")\n    ]\n    \n    var body: some View {\n        VStack {\n            Text(\"ユーザー一覧\")\n                .font(.title)\n            \n            List {\n                ForEach(users) { user in\n                    HStack {\n                        VStack(alignment: .leading, spacing: 4) {\n                            Text(user.name)\n                                .font(.headline)\n                            Text(user.email)\n                                .font(.caption)\n                                .foregroundStyle(.secondary)\n                        }\n                        Spacer()\n                        // IDをバッジで表示\n                        Text(\"#\\(user.id)\")\n                            .font(.caption2)\n                            .padding(.horizontal, 8)\n                            .padding(.vertical, 4)\n                            .background(.blue)\n                            .foregroundStyle(.white)\n                            .cornerRadius(4)\n                    }\n                }\n            }\n        }\n    }\n}\n\n// id の型は:\n// - UUID（ランダムで絶対重複しない）\n// - Int（データベースやサーバーの ID）\n// - String（メールアドレスなど一意な文字列）\n// など、重複しさえすれば何でもOK",
					"output": "（ユーザー情報がID付きで一覧表示される）",
					"executable": false,
					"keywords": ["id", "int", "type", "database", "ユーザー", "データベース"]
				},
				{
					"title": "@Stateと組み合わせた動的リスト",
					"code": "import SwiftUI\n\nstruct Task: Identifiable {\n    let id = UUID()  // 追加・削除時も ID は変わらない\n    var title: String\n    var isCompleted: Bool = false\n}\n\nstruct TodoView: View {\n    @State private var tasks: [Task] = [\n        Task(title: \"数学の宿題\"),\n        Task(title: \"英語の勉強\"),\n        Task(title: \"部屋を片付ける\")\n    ]\n    \n    @State private var newTaskTitle = \"\"\n    \n    var body: some View {\n        VStack {\n            // 新規タスク入力\n            HStack {\n                TextField(\"新しいタスク\", text: $newTaskTitle)\n                    .textFieldStyle(.roundedBorder)\n                \n                Button(\"追加\") {\n                    if !newTaskTitle.isEmpty {\n                        tasks.append(Task(title: newTaskTitle))\n                        newTaskTitle = \"\"  // 入力をクリア\n                    }\n                }\n                .buttonStyle(.borderedProminent)\n            }\n            .padding()\n            \n            // タスク一覧\n            List {\n                ForEach($tasks) { $task in\n                    HStack {\n                        // チェックボックス\n                        Image(systemName: task.isCompleted ? \"checkmark.circle.fill\" : \"circle\")\n                            .foregroundStyle(task.isCompleted ? .green : .gray)\n                            .onTapGesture {\n                                task.isCompleted.toggle()\n                            }\n                        \n                        // タスクテキスト（完了時は取り消し線）\n                        Text(task.title)\n                            .strikethrough(task.isCompleted)\n                        \n                        Spacer()\n                    }\n                }\n                .onDelete { indexSet in\n                    tasks.remove(atOffsets: indexSet)  // 削除機能\n                }\n            }\n        }\n    }\n}\n\n// ポイント:\n// - UUID() で各タスクが一意な ID を持つ\n// - 追加・削除してもIDは変わらない\n// - List の スワイプ削除機能が正確に動作する",
					"output": "（タスク追加・完了・削除ができるTODOリスト）",
					"executable": false,
					"keywords": ["state", "dynamic", "list", "add", "delete", "動的", "追加", "削除"]
				},
				{
					"title": "既存の型を Identifiable にする拡張",
					"code": "import SwiftUI\n\n// 既にあるシンプルな構造体\nstruct Course {\n    var name: String\n    var credits: Int\n}\n\n// extension で Identifiable に準拠させる\n// （元の定義は変えずに機能を追加）\nextension Course: Identifiable {\n    var id: String {\n        // コースの名前を ID として使う\n        // 複数の同名コースがない場合に有効\n        name\n    }\n}\n\nstruct CourseListView: View {\n    let courses = [\n        Course(name: \"数学\", credits: 4),\n        Course(name: \"英語\", credits: 3),\n        Course(name: \"理科\", credits: 4)\n    ]\n    \n    var body: some View {\n        VStack {\n            Text(\"開講科目\")\n                .font(.title)\n            \n            ForEach(courses) { course in\n                HStack {\n                    Text(course.name)\n                        .font(.headline)\n                    Spacer()\n                    Text(\"\\(course.credits)単位\")\n                        .foregroundStyle(.secondary)\n                }\n                .padding()\n                .background(Color(.systemGray6))\n            }\n        }\n        .padding()\n    }\n}\n\n// extension で Identifiable を追加するメリット:\n// - 元の構造体の定義を変えない\n// - 必要に応じて複数の場所で使える\n// - 既存のコードに影響を与えない",
					"output": "（科目一覧が単位数とともに表示される）",
					"executable": false,
					"keywords": ["extension", "protocol", "conform", "拡張", "準拠", "エクステンション"]
				},
				{
					"title": "Identifiable vs id: \\.self の使い分け",
					"code": "import SwiftUI\n\n// === 場面1: シンプルな値型（String, Int） ===\n// → id: \\.self を使う方がシンプル\n\nstruct SimpleListView: View {\n    let fruits = [\"りんご\", \"バナナ\", \"オレンジ\"]\n    \n    var body: some View {\n        VStack {\n            ForEach(fruits, id: \\.self) { fruit in\n                Text(fruit)\n            }\n        }\n    }\n}\n\n// === 場面2: 複雑な型（構造体）の場合 ===\n// → Identifiable に準拠させる方が安全で読みやすい\n\nstruct Student: Identifiable {\n    let id = UUID()\n    var name: String\n    var age: Int\n    var grade: String\n}\n\nstruct StudentListView: View {\n    let students = [\n        Student(name: \"太郎\", age: 13, grade: \"中学1年\"),\n        Student(name: \"花子\", age: 14, grade: \"中学2年\")\n    ]\n    \n    var body: some View {\n        VStack {\n            // Identifiable に準拠しているので id: を省略\n            ForEach(students) { student in\n                Text(\"\\(student.name) (\\(student.age)歳)\")\n            }\n        }\n    }\n}\n\n// === 場面3: 一時的なインデックス取得 ===\n// → indexed() ヘルパーを使う\n\nstruct IndexedListView: View {\n    let items = [\"第1項\", \"第2項\", \"第3項\"]\n    \n    var body: some View {\n        VStack {\n            ForEach(Array(items.enumerated()), id: \\.offset) { index, item in\n                HStack {\n                    Text(\"\\(index + 1): \")\n                        .foregroundStyle(.secondary)\n                    Text(item)\n                }\n            }\n        }\n    }\n}\n\n// 使い分けの目安:\n// - 値型（String, Int）: id: \\.self\n// - 参照型或いは複雑な型: Identifiable に準拠\n// - リスト要素の削除が必要: UUID を使う\n// - スタティックなID: 整数或いは文字列を使う",
					"output": "（各パターンがそれぞれ正しく表示される）",
					"executable": false,
					"keywords": ["self", "difference", "choice", "string", "int", "使い分け", "判断", "比較"]
				}
			],
			"afterHtml": "<div class=\"mt-8\"><h3 class=\"mb-4 text-xl font-bold\">Identifiable が必須な場面</h3><div class=\"overflow-x-auto\"><table class=\"table w-full rounded-box table-zebra bg-base-200\"><thead><tr class=\"bg-base-300\"><th class=\"text-base text-base-content\">場面</th><th class=\"text-base text-base-content\">説明</th><th class=\"text-base text-base-content\">理由</th></tr></thead><tbody><tr><td class=\"font-bold\">List 内のForEach</td><td><code class=\"rounded bg-base-300 px-1\">List { ForEach(items) {...} }</code></td><td>リスト要素の削除・移動を正確に追跡</td></tr><tr><td class=\"font-bold\">TabView 内</td><td>タブの各ビュー要素</td><td>タブの状態管理が正確になる</td></tr><tr><td class=\"font-bold\">@State での配列管理</td><td>追加・削除・編集がある場合</td><td>UUID で一意性を確保</td></tr><tr><td class=\"font-bold\">アニメーション</td><td>要素の削除・追加時</td><td>ID が変わらないことで スムーズなアニメーション</td></tr></tbody></table></div></div>"
		},
		{
			"id": "initializer",
			"title": "初期化メソッド（init）",
			"description": "initはクラスや構造体の「新しいインスタンスを作成するとき」に自動的に呼ばれる特別なメソッドです。インスタンスの初期状態をセットアップします。",
			"codeBlocks": [
				{
					"title": "initの基本",
					"code": "// initはインスタンスを作成するときに呼ばれるメソッド\n// 「初期化子（initializer）」とも呼ばれます\n\nstruct Student {\n    var name: String\n    var age: Int\n    var grade: String\n    \n    // 初期化メソッド（init）\n    init(name: String, age: Int, grade: String) {\n        // 受け取った値をプロパティに代入\n        self.name = name\n        self.age = age\n        self.grade = grade\n        print(\"\\(name)という学生が作成されました\")\n    }\n}\n\n// initを使ってインスタンスを作成\nlet student1 = Student(name: \"太郎\", age: 13, grade: \"中学1年\")\nlet student2 = Student(name: \"花子\", age: 14, grade: \"中学2年\")\n\nprint(\"\\(student1.name)は\\(student1.age)歳です\")\nprint(\"\\(student2.name)は\\(student2.age)歳です\")",
					"output": "太郎という学生が作成されました\n花子という学生が作成されました\n太郎は13歳です\n花子は14歳です",
					"executable": true,
					"keywords": [
						"init",
						"initializer",
						"constructor",
						"initialization",
						"生成",
						"初期化",
						"作成"
					]
				},
				{
					"title": "デフォルト値を使ったinit",
					"code": "// プロパティに初期値を設定しておくと、initを省略できる\n\nstruct Book {\n    var title: String\n    var author: String\n    var publishedYear: Int = 2024  // デフォルト値を設定\n    var isAvailable: Bool = true   // デフォルト値を設定\n    \n    // initを明示的に定義しない場合、Swiftが自動で生成する\n    // （デフォルト初期化子：memberwise initializer）\n}\n\n// デフォルト初期化子を使ってインスタンスを作成\nlet book1 = Book(title: \"Swift入門\", author: \"Aさん\")\n// publishedYearはデフォルト値2024、isAvailableはtrueが使われる\n\nlet book2 = Book(title: \"データベース設計\", author: \"Bさん\", publishedYear: 2020)\n// publishedYearを明示的に指定、isAvailableはデフォルト値true\n\nlet book3 = Book(title: \"アルゴリズム\", author: \"Cさん\", publishedYear: 2019, isAvailable: false)\n// すべてのプロパティを指定\n\nprint(\"\\(book1.title): \\(book1.publishedYear)年発行, 貸出可: \\(book1.isAvailable)\")\nprint(\"\\(book2.title): \\(book2.publishedYear)年発行, 貸出可: \\(book2.isAvailable)\")\nprint(\"\\(book3.title): \\(book3.publishedYear)年発行, 貸出可: \\(book3.isAvailable)\")",
					"output": "Swift入門: 2024年発行, 貸出可: true\nデータベース設計: 2020年発行, 貸出可: true\nアルゴリズム: 2019年発行, 貸出可: false",
					"executable": true,
					"keywords": ["default", "value", "デフォルト", "初期値", "省略"]
				},
				{
					"title": "複数のinitを定義（オーバーロード）",
					"code": "// 複数の異なる形式のinitを定義できる\n// （異なるパラメータで複数の初期化方法を提供）\n\nstruct Point {\n    var x: Double\n    var y: Double\n    \n    // init1: x と y を指定する方法\n    init(x: Double, y: Double) {\n        self.x = x\n        self.y = y\n    }\n    \n    // init2: 1つの値で x と y の両方を設定する方法\n    init(value: Double) {\n        self.x = value\n        self.y = value\n    }\n    \n    // init3: 何も指定しない場合は原点(0, 0)に初期化\n    init() {\n        self.x = 0\n        self.y = 0\n    }\n}\n\n// 異なる初期化方法を使用\nlet point1 = Point(x: 3, y: 4)  // init1を使用\nlet point2 = Point(value: 5)     // init2を使用\nlet point3 = Point()             // init3を使用\n\nprint(\"Point1: (\\(point1.x), \\(point1.y))\")\nprint(\"Point2: (\\(point2.x), \\(point2.y))\")\nprint(\"Point3: (\\(point3.x), \\(point3.y))\")",
					"output": "Point1: (3.0, 4.0)\nPoint2: (5.0, 5.0)\nPoint3: (0.0, 0.0)",
					"executable": true,
					"keywords": ["overload", "multiple", "複数", "オーバーロード", "初期化方法"]
				},
				{
					"title": "クラスでのinit（継承との関係）",
					"code": "// クラスではinitの書き方に注意が必要\n// すべてのプロパティを初期化する必要がある\n\nclass Animal {\n    var name: String\n    var age: Int\n    \n    // クラスのinit（designated initializer）\n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n        print(\"\\(name)という動物が作成されました\")\n    }\n}\n\nclass Dog: Animal {  // Animalを継承したDogクラス\n    var breed: String\n    \n    // Dogの独自のinit\n    init(name: String, age: Int, breed: String) {\n        self.breed = breed             // 自分のプロパティを初期化\n        super.init(name: name, age: age)  // 親クラスのinitを呼ぶ\n    }\n    \n    // convenience initializer（便利初期化子）\n    // designated initializerを呼び出すラッパー\n    convenience init(name: String) {\n        self.init(name: name, age: 0, breed: \"不明\")\n    }\n}\n\nlet dog1 = Dog(name: \"太郎\", age: 3, breed: \"ゴールデンレトリバー\")\nlet dog2 = Dog(name: \"花子\")  // convenience initを使用\n\nprint(\"\\(dog1.name)は\\(dog1.breed)です\")\nprint(\"\\(dog2.name)は\\(dog2.breed)です (年齢: \\(dog2.age))\")",
					"output": "太郎という動物が作成されました\n花子という動物が作成されました\n太郎はゴールデンレトリバーです\n花子は不明です (年齢: 0)",
					"executable": true,
					"keywords": [
						"class",
						"inheritance",
						"super",
						"convenience",
						"designated",
						"継承",
						"親クラス"
					]
				},
				{
					"title": "失敗可能なinit（failable initializer）",
					"code": "// 初期化が失敗する可能性がある場合は、init? を使う\n// 初期化に成功するとインスタンスを返し、失敗するとnilを返す\n\nstruct User {\n    var name: String\n    var age: Int\n    \n    // 失敗可能なinit（init?）\n    // ageが0以下または150以上なら失敗\n    init?(name: String, age: Int) {\n        // バリデーション（確認）\n        if age <= 0 || age >= 150 {\n            // 初期化を失敗させる\n            return nil\n        }\n        \n        // 条件を満たしたら初期化を続ける\n        self.name = name\n        self.age = age\n    }\n}\n\n// 成功するケース\nif let user1 = User(name: \"太郎\", age: 13) {\n    print(\"\\(user1.name)ユーザーを作成しました（年齢: \\(user1.age)）\")\n} else {\n    print(\"ユーザー作成に失敗しました\")\n}\n\n// 失敗するケース（年齢が無効）\nif let user2 = User(name: \"花子\", age: -5) {\n    print(\"\\(user2.name)ユーザーを作成しました\")\n} else {\n    print(\"年齢が無効のため、ユーザー作成に失敗しました\")\n}\n\n// 失敗するケース（年齢が大きすぎる）\nif let user3 = User(name: \"次郎\", age: 200) {\n    print(\"\\(user3.name)ユーザーを作成しました\")\n} else {\n    print(\"年齢が無効のため、ユーザー作成に失敗しました\")\n}",
					"output": "太郎ユーザーを作成しました（年齢: 13）\n年齢が無効のため、ユーザー作成に失敗しました\n年齢が無効のため、ユーザー作成に失敗しました",
					"executable": true,
					"keywords": [
						"failable",
						"optional",
						"init?",
						"validation",
						"バリデーション",
						"失敗",
						"nil"
					]
				},
				{
					"title": "SwiftData @Modelでのinit",
					"code": "import Foundation\nimport SwiftData\n\n// @Modelをつけたクラスではinitを独自に定義できる\n@Model\nfinal class ToDoTask: Identifiable {\n    var id: UUID = UUID()        // 各タスクに一意のID\n    var title: String = \"\"       // タスクのタイトル\n    var detail: String = \"\"      // タスクの詳細\n    var isCompleted: Bool = false // 完了フラグ\n    var tabId: UUID = UUID()     // どのタブに属しているか\n    var createdAt: Date = Date() // 作成日時\n    \n    // 初期化メソッド\n    // title, detail, tabIdを指定して、それ以外はデフォルト値を使う\n    init(title: String, detail: String, tabId: UUID) {\n        self.title = title\n        self.detail = detail\n        self.isCompleted = false     // 作成時は未完了\n        self.tabId = tabId\n        self.createdAt = Date()      // 現在時刻を自動設定\n        // idはUUID()で自動生成される\n    }\n}\n\n// 使用例\nlet taskId = UUID()\nlet task1 = ToDoTask(title: \"数学の宿題\", detail: \"第3章の問題を解く\", tabId: taskId)\nlet task2 = ToDoTask(title: \"英語の単語\", detail: \"100個暗記する\", tabId: taskId)\n\nprint(\"タスク1: \\(task1.title)\")\nprint(\"  詳細: \\(task1.detail)\")\nprint(\"  完了: \\(task1.isCompleted)\")\nprint(\"  作成日時: \\(task1.createdAt)\")\nprint()\nprint(\"タスク2: \\(task2.title)\")\nprint(\"  詳細: \\(task2.detail)\")",
					"output": "タスク1: 数学の宿題\n  詳細: 第3章の問題を解く\n  完了: false\n  作成日時: 2026-02-20 10:00:00 +0000\n\nタスク2: 英語の単語\n  詳細: 100個暗記する",
					"executable": true,
					"keywords": [
						"swiftdata",
						"model",
						"database",
						"dataset",
						"persistent",
						"データベース",
						"永続化"
					]
				}
			],
			"afterHtml": "<div class=\"mt-8\"><h3 class=\"mb-4 text-xl font-bold\">initの種類と使い分け</h3><div class=\"overflow-x-auto\"><table class=\"table w-full rounded-box table-zebra bg-base-200\"><thead><tr class=\"bg-base-300\"><th class=\"text-base text-base-content\">種類</th><th class=\"text-base text-base-content\">記号</th><th class=\"text-base text-base-content\">説明</th><th class=\"text-base text-base-content\">例</th></tr></thead><tbody><tr><td class=\"font-bold\">通常のinit</td><td><code class=\"rounded bg-base-300 px-1\">init(...)</code></td><td>インスタンス作成に成功する</td><td><code class=\"rounded bg-base-300 px-1\">init(name: String)</code></td></tr><tr><td class=\"font-bold\">失敗可能</td><td><code class=\"rounded bg-base-300 px-1\">init?(...)</code></td><td>失敗時はnil、成功時はインスタンス</td><td><code class=\"rounded bg-base-300 px-1\">init?(age: Int)</code></td></tr><tr><td class=\"font-bold\">便利初期化子</td><td><code class=\"rounded bg-base-300 px-1\">convenience init</code></td><td>別のinitを呼び出すラッパー</td><td><code class=\"rounded bg-base-300 px-1\">convenience init(name: String)</code></td></tr><tr><td class=\"font-bold\">デフォルト</td><td>なし</td><td>プロパティに初期値があると自動生成</td><td>全プロパティがデフォルト値を持つ</td></tr></tbody></table></div></div>"
		},
		{
			"id": "self",
			"title": "self（自分自身への参照）",
			"description": "selfはインスタンスが自分自身を参照するときに使います。Swiftでは多くの場合省略できますが、明示的に書くことで意図がより明確になります。",
			"codeBlocks": [
				{
					"title": "selfの基本的な使い方",
					"code": "// selfはインスタンスが自分自身を指す\n// 多くの場合は省略できますが、明示的に書くこともできます\n\nstruct Student {\n    var name: String\n    var age: Int\n    \n    // メソッド内でプロパティにアクセス\n    func introduce() {\n        // 省略形: self を使わない\n        print(\"私の名前は\\(name)です\")  // nameはこのインスタンスのプロパティ\n        \n        // 明示形: self を使う（同じ結果）\n        print(\"私の名前は\\(self.name)です\")\n    }\n    \n    // 別のインスタンスとの比較\n    func isSameAge(as other: Student) -> Bool {\n        // selfを使ってこのインスタンスと比較対象を区別\n        return self.age == other.age\n    }\n}\n\nlet student1 = Student(name: \"太郎\", age: 13)\nlet student2 = Student(name: \"花子\", age: 13)\n\nstudent1.introduce()\nprint(\"同じ年齢: \\(student1.isSameAge(as: student2))\")",
					"output": "私の名前は太郎です\n私の名前は太郎です\n同じ年齢: true",
					"executable": true,
					"keywords": ["self", "reference", "instance", "参照", "インスタンス", "自分自身"]
				},
				{
					"title": "initでのself の重要性",
					"code": "// ===== 【重要】initで self を書く理由 =====\n// パラメータとプロパティの名前が同じときは、\n// 「self.」を書かないと、データが保存されません！\n// \n// 例える と：\n// 【プロパティ】= データを保存する箱\n// 【パラメータ】= 関数が受け取る値\n// selfなしだと、「受け取った値を、受け取った値に入れる」という操作になります\n\n// ✅ 正しい例\nstruct Student {\n    var name: String      // 【プロパティ】学生の名前を保存する場所\n    var grade: Int        // 学年を保存する場所\n    \n    init(name: String, grade: Int) {     // name, grade は受け取った値\n        self.name = name                 // ✅ 箱に入れる！\n        self.grade = grade               // ✅ 箱に入れる！\n    }\n}\n\nlet student = Student(name: \"太郎\", grade: 1)\nprint(\"\\(student.name)は\\(student.grade)年生\")  // 太郎は1年生\n\n// ❌ 間違った例\nstruct BadStudent {\n    var name: String\n    var grade: Int\n    \n    init(name: String, grade: Int) {\n        name = name        // ❌ 受け取った値の中身 = 受け取った値の中身（意味なし）\n        grade = grade      // ❌ 箱が埋まらないままになる！\n    }\n}\n\nlet badStudent = BadStudent(name: \"太郎\", grade: 1)\nprint(\"\\(badStudent.name)は\\(badStudent.grade)年生\")  // [空]は[0]年生\n\n// === わかりやすい図解 ===\n// \n// ✅ self.name = name の場合:\n//\n//   init(name: \"太郎\") を呼ぶと...\n//\n//     ┌──────────┐     ┌──────────┐\n//     │ 【箱】    │ ←   │ 受け取った値 │\n//     │ self.name│     │ \"太郎\"   │\n//     └──────────┘     └──────────┘\n//       成功 ✅\n//\n//\n// ❌ name = name の場合:\n//\n//   init(name: \"太郎\") を呼ぶと...\n//\n//     ┌──────────┐\n//     │【 箱 】   │  ← 開いたままで空\n//     │ self.name│\n//     └──────────┘\n//\n//     │ 受け取った値 │\n//     │ \"太郎\"      │  ← この値は使われず\n//      \n//       失敗 ❌",
					"output": "太郎は1年生\n[空]は[0]年生",
					"executable": true,
					"keywords": ["init", "parameter", "property", "プロパティ", "パラメータ", "区別", "self"]
				},
				{
					"title": "selfをパラメータとして渡す",
					"code": "// メソッドでself全体を別の関数に渡す場合\n\nstruct Rectangle {\n    var width: Double\n    var height: Double\n    \n    // このインスタンス自体を別の関数に渡す\n    func printSize() {\n        // self全体を関数に渡す\n        describeShape(self)\n    }\n}\n\n// 外部の関数（型の外側で定義）\nfunc describeShape(_ shape: Rectangle) {\n    print(\"矩形: 幅 \\(shape.width), 高さ \\(shape.height)\")\n    print(\"面積: \\(shape.width * shape.height)\")\n}\n\nlet rect = Rectangle(width: 10, height: 20)\nrect.printSize()\n\n// describeShape(rect) と同じ結果\nrect.printSize()  // 内部でself をパラメータとして渡している",
					"output": "矩形: 幅 10.0, 高さ 20.0\n面積: 200.0\n矩形: 幅 10.0, 高さ 20.0\n面積: 200.0",
					"executable": true,
					"keywords": ["parameter", "pass", "function", "渡す", "関数", "自身"]
				},
				{
					"title": "mutatingメソッドでのself",
					"code": "// 値型（struct）は中身を変更するメソッドを「mutating」にする必要がある\n// mutatingメソッド内では、self全体を置き換えることもできる\n\nstruct Counter {\n    var count = 0\n    \n    // mutatingをつけることで、プロパティを変更できるメソッドにする\n    mutating func increment() {\n        self.count += 1  // または単に count += 1\n    }\n    \n    // 値を指定してカウンターをリセット\n    mutating func reset(to value: Int) {\n        self.count = value\n    }\n    \n    // self全体を新しい値に置き換える\n    mutating func replicate() {\n        // このカウンターを2倍の値で初期化し直す\n        self = Counter(count: count * 2)\n    }\n}\n\nvar counter = Counter(count: 5)\ncounter.increment()\nprint(\"カウント: \\(counter.count)\")  // 6\n\ncounter.reset(to: 10)\nprint(\"リセット: \\(counter.count)\")   // 10\n\ncounter.replicate()\nprint(\"複製: \\(counter.count)\")        // 20（10 * 2）",
					"output": "カウント: 6\nリセット: 10\n複製: 20",
					"executable": true,
					"keywords": ["mutating", "struct", "modify", "置き換える", "値型", "変更"]
				},
				{
					"title": "クロージャでのself",
					"code": "// クロージャ内でselfを使う場合、メモリリークを防ぐために [weak self] を使う\n// （クラスの場合、強い参照サイクルが発生する可能性があるため）\n\nclass DataFetcher {\n    var name: String\n    var resultHandler: (() -> Void)?\n    \n    init(name: String) {\n        self.name = name\n    }\n    \n    func fetchData() {\n        // クロージャを定義\n        // [weak self] でselfへの弱参照を使う\n        // selfが破棄されたら nil になる\n        resultHandler = { [weak self] in\n            if let self = self {\n                // selfが存在する場合のみ処理\n                print(\"\\(self.name)のデータ取得完了\")\n            } else {\n                print(\"このオブジェクトは既に破棄されています\")\n            }\n        }\n    }\n    \n    // [unowned self] の例（危険なので注意）\n    // selfが絶対に破棄されないことが確実な場合に使う\n    func setCallback() {\n        resultHandler = { [unowned self] in\n            print(\"\\(self.name)がコールバック処理を実行\")\n        }\n    }\n}\n\nvar fetcher: DataFetcher? = DataFetcher(name: \"API\")\nfetcher?.fetchData()\nfetcher?.resultHandler?()\n\n// fetcher を破棄\nfetcher = nil\n// 以下を実行すると、resultHandler? は nil なので何もしない\n// または、[weak self] があれば \"このオブジェクトは既に破棄\" のメッセージが出る可能性",
					"output": "APIのデータ取得完了\n",
					"executable": false,
					"keywords": [
						"closure",
						"weak",
						"unowned",
						"reference cycle",
						"memory leak",
						"クロージャ",
						"メモリリーク"
					]
				},
				{
					"title": "値型と参照型でのselfの違い",
					"code": "// === 値型（struct）での self ===\nstruct ValueType {\n    var value: Int\n    \n    mutating func change() {\n        self.value = 100  // 自分自身の値を変更\n        // 値型は mutating が必要\n    }\n}\n\nvar vt = ValueType(value: 10)\nvt.change()\nprint(\"値型のvalue: \\(vt.value)\")  // 100\n\n// === 参照型（class）での self ===\nclass ReferenceType {\n    var value: Int\n    \n    init(value: Int) {\n        self.value = value\n    }\n    \n    func change() {\n        self.value = 100  // mutating は不要\n        // 参照型はメモリ上の同じオブジェクトを変更するため\n    }\n}\n\nlet rt = ReferenceType(value: 10)\nrt.change()\nprint(\"参照型のvalue: \\(rt.value)\")  // 100\n\n// === 違い ===\n// 値型（struct）:\n//   - mutating をつけないとプロパティを変更できない\n//   - self = ... で全体を置き換え可能\n//   - 値をコピーするので、original と変更後は別物\n\n// 参照型（class）:\n//   - mutating は不要（常にメモリ上の同じオブジェクト）\n//   - let で宣言しても、プロパティは変更可能\n//   - すべての参照者が同じオブジェクトを見る",
					"output": "値型のvalue: 100\n参照型のvalue: 100",
					"executable": true,
					"keywords": [
						"struct",
						"class",
						"value type",
						"reference type",
						"mutating",
						"違い",
						"値型",
						"参照型"
					]
				}
			],
			"afterHtml": "<div class=\"mt-8\"><h3 class=\"mb-4 text-xl font-bold\">self を使う場面まとめ</h3><div class=\"overflow-x-auto\"><table class=\"table w-full rounded-box table-zebra bg-base-200\"><thead><tr class=\"bg-base-300\"><th class=\"text-base text-base-content\">場面</th><th class=\"text-base text-base-content\">使う理由</th><th class=\"text-base text-base-content\">例</th></tr></thead><tbody><tr><td class=\"font-bold\">init で パラメータ = プロパティ</td><td>区別を明確にする</td><td><code class=\"rounded bg-base-300 px-1\">self.name = name</code></td></tr><tr><td class=\"font-bold\">複数のインスタンスを比較</td><td>「どのインスタンスか」を明示</td><td><code class=\"rounded bg-base-300 px-1\">self.age == other.age</code></td></tr><tr><td class=\"font-bold\">インスタンス全体を渡す</td><td>メソッドから関数へ</td><td><code class=\"rounded bg-base-300 px-1\">function(self)</code></td></tr><tr><td class=\"font-bold\">mutating で全体置換</td><td>値型で新しい値に初期化し直す</td><td><code class=\"rounded bg-base-300 px-1\">self = Type(...)</code></td></tr><tr><td class=\"font-bold\">クロージャ内での参照</td><td>メモリリーク防止 [weak self]</td><td><code class=\"rounded bg-base-300 px-1\">{ [weak self] in ... }</code></td></tr></tbody></table></div></div>"
		},
		{
			"id": "swiftdata-persistence",
			"title": "SwiftData（データ永続化）",
			"description": "ModelContextを使ってデータベース操作を行います。Swiftでデータを保存・読み込み・削除するための基本操作を学びます。",
			"codeBlocks": [
				{
					"title": "modelContext.insert（データ追加）",
					"code": "// 【modelContext.insert() の役割】\n// insert() は新しいデータをDBに追加する「準備」をします。\n// ⚠️ この時点ではまだDB には書き込まれていません！\n// save() を呼ぶことで初めて確定します。\n//\n// 【流れ】\n// ステップ1: ToDoTask インスタンスを作成する\n// ステップ2: insert(task) で「追加待ちリスト」に追加\n// ステップ3: save() で「待ちリスト」の内容をDB に確定\n//\n// 【複数データを追加するときは？】\n// 複数回 insert() してから、最後に1回だけ save() すると\n// 効率的です！\n\nimport Foundation\nimport SwiftData\n\n// ToDoタスクモデル\n@Model\nfinal class ToDoTask {\n    var title: String\n    var isCompleted: Bool = false\n    \n    init(title: String, isCompleted: Bool = false) {\n        self.title = title\n        self.isCompleted = isCompleted\n    }\n}\n\n// ModelContextを使ったデータ追加\n@MainActor\nfunc addNewTask(title: String, to modelContext: ModelContext) {\n    // 1. 新しいタスクを作成\n    let newTask = ToDoTask(title: title)\n    \n    // 2. insert() で「保存待ちリスト」に追加\n    // まだこの時点ではデータベースに書き込まれない\n    modelContext.insert(newTask)\n    \n    // 3. save() でデータベースに永続化\n    try? modelContext.save()\n    \n    print(\"タスク『\\(title)』を追加しました\")\n}\n\n// 複数のタスクを一度に追加\n@MainActor\nfunc addMultipleTasks(titles: [String], to modelContext: ModelContext) {\n    for title in titles {\n        let task = ToDoTask(title: title)\n        modelContext.insert(task)  // 複数追加してから...\n    }\n    try? modelContext.save()  // 一度に保存すると効率的\n}",
					"output": "タスク『宿題を終わらせる』を追加しました",
					"executable": false,
					"keywords": [
						"modelContext",
						"insert",
						"save",
						"database",
						"データ追加",
						"永続化",
						"SwiftData"
					]
				},
				{
					"title": "modelContext.delete（データ削除）",
					"code": "import Foundation\nimport SwiftData\n\n// 単一のタスクを削除\n@MainActor\nfunc deleteTask(_ task: ToDoTask, from modelContext: ModelContext) {\n    // delete() で削除対象にマーク\n    modelContext.delete(task)\n    \n    // save() で変更を永続化\n    try? modelContext.save()\n    \n    print(\"タスクを削除しました\")\n}\n\n// 条件に合うすべてのタスクを削除（例：完了済みのタスク）\n@MainActor\nfunc deleteCompletedTasks(from modelContext: ModelContext) {\n    // FetchDescriptor で削除対象を指定\n    let descriptor = FetchDescriptor<ToDoTask>(\n        predicate: #Predicate { $0.isCompleted == true }\n    )\n    \n    // 条件に合うデータを取得して削除\n    if let completedTasks = try? modelContext.fetch(descriptor) {\n        for task in completedTasks {\n            modelContext.delete(task)\n        }\n        try? modelContext.save()\n        print(\"\\(completedTasks.count)個の完了済みタスクを削除しました\")\n    }\n}",
					"output": "タスクを削除しました\n2個の完了済みタスクを削除しました",
					"executable": false,
					"keywords": [
						"delete",
						"remove",
						"predicate",
						"削除",
						"条件削除",
						"SwiftData",
						"modelContext"
					]
				},
				{
					"title": "modelContext.save（データ保存）",
					"code": "import Foundation\nimport SwiftData\n\n@Model\nfinal class ToDoTask {\n    var title: String\n    var isCompleted: Bool = false\n    \n    init(title: String, isCompleted: Bool = false) {\n        self.title = title\n        self.isCompleted = isCompleted\n    }\n}\n\n// save() は変更をデータベースに記録する\n@MainActor\nfunc updateTask(_ task: ToDoTask, newTitle: String, modelContext: ModelContext) {\n    // 1. プロパティを変更\n    task.title = newTitle\n    task.isCompleted = true\n    \n    // 2. save() で変更をデータベースに反映\n    // SwiftDataは自動追跡なので、save() だけで十分\n    // insert() や update() の呼び出しは不要\n    try? modelContext.save()\n    \n    print(\"タスクを更新しました: \\(newTitle)\")\n}\n\n// try-catch でエラー処理\n@MainActor\nfunc saveWithErrorHandling(task: ToDoTask, modelContext: ModelContext) {\n    do {\n        // save() が失敗する可能性がある場合\n        try modelContext.save()\n        print(\"保存成功\")\n    } catch {\n        // エラーが発生した場合の処理\n        print(\"保存失敗: \\(error.localizedDescription)\")\n    }\n}",
					"output": "タスクを更新しました: 宿題を終わらせる\n保存成功",
					"executable": false,
					"keywords": ["save", "persist", "database", "commit", "保存", "永続化", "変更反映"]
				},
				{
					"title": "modelContext.fetch（データ取得）",
					"code": "import Foundation\nimport SwiftData\n\n@Model\nfinal class ToDoTask {\n    var title: String\n    var isCompleted: Bool = false\n    \n    init(title: String, isCompleted: Bool = false) {\n        self.title = title\n        self.isCompleted = isCompleted\n    }\n}\n\n// すべてのタスクを取得\n@MainActor\nfunc getAllTasks(from modelContext: ModelContext) -> [ToDoTask] {\n    // FetchDescriptor: 「データの取得方法」を指定する設定書\n    let descriptor = FetchDescriptor<ToDoTask>()\n    \n    if let tasks = try? modelContext.fetch(descriptor) {\n        return tasks\n    }\n    return []\n}\n\n// 条件付きでデータを取得\n@MainActor\nfunc getUncompletedTasks(from modelContext: ModelContext) -> [ToDoTask] {\n    // #Predicate: 「取得する条件」を定義\n    // $0 は対象となる各要素を表す\n    let descriptor = FetchDescriptor<ToDoTask>(\n        predicate: #Predicate { $0.isCompleted == false }\n    )\n    \n    if let tasks = try? modelContext.fetch(descriptor) {\n        return tasks\n    }\n    return []\n}\n\n// ソート付きでデータを取得\n@MainActor\nfunc getTasksSorted(from modelContext: ModelContext) -> [ToDoTask] {\n    // SortDescriptor で並べ替え順序を指定\n    let sortDescriptor = SortDescriptor(\\ToDoTask.title)\n    let descriptor = FetchDescriptor<ToDoTask>(sortBy: [sortDescriptor])\n    \n    if let tasks = try? modelContext.fetch(descriptor) {\n        return tasks  // titleでアルファベット順にソート済み\n    }\n    return []\n}",
					"output": "// tasks = [ ToDoTask(title: \"宿題を終わらせる\", isCompleted: false), ... ]",
					"executable": false,
					"keywords": [
						"fetch",
						"query",
						"FetchDescriptor",
						"Predicate",
						"取得",
						"照会",
						"データベース検索"
					]
				}
			],
			"afterHtml": "<div class=\"mt-8\"><h3 class=\"mb-4 text-xl font-bold\">ModelContextの基本操作フロー</h3><p class=\"mb-4 text-sm text-base-content/70\">データベース操作は3つのステップで進みます。insert()やdelete()で「変更待ちリスト」に追加して、最後にsave()で全部をデータベースに一括反映する流れです。</p><div class=\"mb-6 p-4 bg-base-100 rounded-lg border border-base-300\"><div class=\"text-sm font-mono text-left\"><p class=\"mb-2\">【基本的な流れ】</p><p class=\"mb-2\">1️⃣ insert(task)     → 新しいデータを「追加待ちリスト」に入れる</p><p class=\"mb-2\">2️⃣ delete(task)     → 不要なデータを「削除待ちリスト」に入れる</p><p class=\"mb-2\">3️⃣ save()           → リストに入ってるものすべてをDB に確定する</p></div></div><div class=\"overflow-x-auto mb-6\"><table class=\"table w-full rounded-box table-zebra bg-base-200\"><thead><tr class=\"bg-base-300\"><th class=\"text-base text-base-content\">操作</th><th class=\"text-base text-base-content\">説明</th><th class=\"text-base text-base-content\">タイミング</th><th class=\"text-base text-base-content\">使用例</th></tr></thead><tbody><tr><td class=\"font-bold\">insert()</td><td>新しいデータを追加する準備（確定ではない）</td><td>データ作成直後</td><td><code class=\"rounded bg-base-300 px-1\">modelContext.insert(task)</code></td></tr><tr><td class=\"font-bold\">delete()</td><td>データを削除する準備（確定ではない）</td><td>削除前に呼び出す</td><td><code class=\"rounded bg-base-300 px-1\">modelContext.delete(task)</code></td></tr><tr><td class=\"font-bold\">save()</td><td>insert/delete/変更をすべてDB に確定</td><td>すべての操作後</td><td><code class=\"rounded bg-base-300 px-1\">try? modelContext.save()</code></td></tr><tr><td class=\"font-bold\">fetch()</td><td>条件に合うデータをDB から検索取得</td><td>データを読む必要があるとき</td><td><code class=\"rounded bg-base-300 px-1\">modelContext.fetch(descriptor)</code></td></tr><tr><td class=\"font-bold\">@MainActor</td><td>メインスレッド でのみ実行することを強制</td><td>Swift UI で画面更新が必要なメソッド</td><td><code class=\"rounded bg-base-300 px-1\">@MainActor func addTask(...)</code></td></tr></tbody></table></div><div class=\"p-4 bg-success/10 border border-success rounded-lg\"><p class=\"text-sm font-bold mb-2\">💡 重要ポイント</p><p class=\"text-sm\"><strong>insert() と delete() だけでは確定しない</strong> - これらは「待ちリスト」に入れるだけです。必ず <code class=\"rounded bg-base-300 px-1\">save()</code> を呼ぶことでデータベースに反映されます。複数の操作をまとめて、最後に1回だけ save() を呼ぶと効率的です。</p></div></div>"
		}
	]
}
