{
	"sections": [
		{
			"id": "basic",
			"title": "基本コンポーネント",
			"description": "アプリ構築の基礎となる基本的なビューです。",
			"codeBlocks": [
				{
					"title": "Text - テキストの表示",
					"description": "アプリ内でテキストを表示するための最も基本的なコンポーネントです。",
					"code": "// 基本的なテキスト\nText(\"Hello, World!\")\n\n// Markdown記法のサポート\nText(\"**太字** と *斜体* と [リンク](https://apple.com)\")\n\n// 日付の表示スタイル\nText(Date(), style: .date)     // 2024年1月1日\nText(Date(), style: .time)     // 12:00\nText(Date(), style: .relative) // 2時間前\nText(Date(), style: .timer)    // 0:00 (カウントアップ)\n\n// 数値のフォーマット\nText(1000, format: .currency(code: \"JPY\")) // ¥1,000",
					"keywords": ["label", "string", "font", "display", "文字", "表示"]
				},
				{
					"title": "Image - 画像の表示",
					"description": "画像を表示するためのコンポーネントです。SF Symbolsやアセット画像の表示が可能です。",
					"code": "// システムアイコン (SF Symbols)\nImage(systemName: \"star.fill\")\n    .foregroundStyle(.yellow)\n\n// アセット画像\nImage(\"ProfilePicture\")\n    .resizable()        // サイズ変更を許可\n    .aspectRatio(contentMode: .fit) // アスペクト比を維持\n    .frame(width: 100)\n\n// 非同期画像の読み込み\nAsyncImage(url: URL(string: \"https://example.com/icon.png\")) {\n    image in image.resizable()\n} placeholder: {\n    ProgressView()\n}",
					"keywords": ["picture", "photo", "icon", "symbol", "sf symbols", "画像", "アイコン"]
				},
				{
					"title": "Button - ボタン",
					"description": "タップ操作を受け付け、アクションを実行するボタンコンポーネントです。",
					"code": "// 基本的なボタン\nButton(\"タップして実行\") {\n    print(\"実行されました\")\n}\n\n// テキスト以外のラベル\nButton(action: {\n    // アクション\n}) {\n    HStack {\n        Image(systemName: \"trash\")\n        Text(\"削除\")\n    }\n}\n\n// ロール指定（破壊的なアクションなど）\nButton(\"削除\", role: .destructive) {\n    // 削除処理\n}",
					"keywords": ["action", "tap", "click", "interaction", "ボタン", "タップ"]
				},
				{
					"title": "Menu - メニューボタン",
					"code": "// Menu はタップするとアクションのリストが表示されるコンポーネント\n// ツールバーなどでよく使用される\n\n// === 基本的な使い方 ===\n\n// シンプルなメニュー\nMenu(\"メニュー\") {\n    Button(\"編集\") { }\n    Button(\"削除\") { }\n    Button(\"共有\") { }\n}\n\n// アイコン付きメニュー\nMenu {\n    Button(action: {}) {\n        Label(\"編集\", systemImage: \"pencil\")\n    }\n    Button(action: {}) {\n        Label(\"削除\", systemImage: \"trash\")\n    }\n    Button(action: {}) {\n        Label(\"共有\", systemImage: \"square.and.arrow.up\")\n    }\n} label: {\n    Image(systemName: \"ellipsis.circle\")\n        .font(.system(size: 24))\n}\n\n// === テキストと一緒に表示 ===\n\nMenu {\n    Button(\"昇順\") { }\n    Button(\"降順\") { }\n    Button(\"名前順\") { }\n} label: {\n    HStack {\n        Image(systemName: \"arrow.up.arrow.down\")\n        Text(\"ソート\")\n    }\n}\n\n// === セクション分け ===\n\nMenu(\"その他\") {\n    Section(\"編集\") {\n        Button(\"編集\", action: { })\n        Button(\"複製\", action: { })\n    }\n    \n    Section(\"削除\") {\n        Button(\"ゴミ箱へ移動\", action: { })\n        Button(\"完全に削除\", action: { })\n    }\n}\n\n// === 破壊的なアクション（赤色） ===\n\nMenu(\"アクション\") {\n    Button(\"完了\", action: { })\n    \n    Button(role: .destructive) {\n        Label(\"削除\", systemImage: \"trash\")\n    } action: {\n        // 削除処理\n    }\n}\n\n// === ツールバー内での使用（最も一般的） ===\n\nstruct ContentView: View {\n    @State private var sortBy = \"名前\"\n    \n    var body: some View {\n        NavigationStack {\n            List {\n                Text(\"項目1\")\n                Text(\"項目2\")\n                Text(\"項目3\")\n            }\n            .navigationTitle(\"リスト\")\n            .toolbar {\n                ToolbarItem(placement: .topBarTrailing) {\n                    Menu {\n                        Button(\"名前順\") { sortBy = \"名前\" }\n                        Button(\"日付順\") { sortBy = \"日付\" }\n                        Button(\"サイズ順\") { sortBy = \"サイズ\" }\n                    } label: {\n                        Image(systemName: \"arrow.up.arrow.down\")\n                    }\n                }\n            }\n        }\n    }\n}\n\n// === 実践的な例：複数のアクション ===\n\nstruct ArticleOptionsMenu: View {\n    @State private var isShowing = false\n    let articleId: String\n    \n    var body: some View {\n        Menu {\n            Button(action: { }) {\n                Label(\"読む\", systemImage: \"book\")\n            }\n            \n            Button(action: { }) {\n                Label(\"共有\", systemImage: \"square.and.arrow.up\")\n            }\n            \n            Button(action: { }) {\n                Label(\"お気に入り\", systemImage: \"star\")\n            }\n            \n            Divider()\n            \n            Button(role: .destructive, action: { }) {\n                Label(\"削除\", systemImage: \"trash\")\n            }\n        } label: {\n            Image(systemName: \"ellipsis\")\n                .foregroundStyle(.blue)\n        }\n    }\n}\n\n// === Pickerのメニュースタイル との違い ===\n\n// Menu は単なるボタンのリスト\nMenu(\"アクション\") {\n    Button(\"アクション1\") { }\n    Button(\"アクション2\") { }\n}\n\n// Picker でメニュースタイルを使用すると、選択状態を管理できる\n@State private var selection = 0\nlet options = [\"オプション1\", \"オプション2\", \"オプション3\"]\n\nPicker(\"選択\", selection: $selection) {\n    ForEach(0..<options.count, id: \\.self) { index in\n        Text(options[index]).tag(index)\n    }\n}\n.pickerStyle(.menu)  // メニューのような表示だが、選択状態を管理",
					"keywords": [
						"menu",
						"action",
						"dropdown",
						"ellipsis",
						"toolbar",
						"button",
						"options",
						"メニュー",
						"アクション",
						"ドロップダウン",
						"ボタン",
						"その他"
					]
				}
			]
		},
		{
			"id": "layout",
			"title": "レイアウトコンテナ",
			"description": "ビューを配置・整理するためのコンテナです。",
			"codeBlocks": [
				{
					"title": "Stacks - 水平・垂直・重ね合わせ",
					"code": "// 垂直方向（縦）に並べる\nVStack(alignment: .leading, spacing: 10) {\n    Text(\"タイトル\")\n    Text(\"詳細説明\")\n}\n\n// 水平方向（横）に並べる\nHStack {\n    Image(systemName: \"person\")\n    Text(\"ユーザー名\")\n}\n\n// 重ねて配置（奥から手前へ）\nZStack {\n    Rectangle().fill(.blue)\n    Text(\"前面のテキスト\").foregroundStyle(.white)\n}",
					"keywords": [
						"VStack",
						"HStack",
						"ZStack",
						"layout",
						"arrange",
						"container",
						"スタック",
						"縦並び",
						"横並び",
						"重ねる"
					]
				},
				{
					"title": "Capsule / 基本シェイプ - 形状の描画",
					"description": "Capsuleは角が完全に丸い長方形（ピル型）を描くシェイプです。ボタンやタグの背景によく使われます。",
					"code": "// Capsule（ピル型の角丸長方形）\nCapsule()\n    .fill(.blue)        // .fill: シェイプを色で塗りつぶす\n    .frame(width: 200, height: 50)\n\n// .fill の詳細\n// fill: シェイプの内部を指定の色で完全に塗りつぶすメソッド\n// stroke: 枠線だけを描く（内部は透明）\n// 単色だけでなく、グラデーションも指定可能\n\nCapsule()\n    .fill(\n        LinearGradient(\n            gradient: Gradient(colors: [.blue, .purple]),\n            startPoint: .topLeading,\n            endPoint: .bottomTrailing\n        )\n    )\n    .frame(width: 200, height: 50)\n\n// ボタンの背景として使う例\nText(\"タグ\")\n    .padding(.horizontal, 16)\n    .padding(.vertical, 8)\n    .background(Capsule().fill(.blue))\n    .foregroundStyle(.white)\n\n// 枠線だけのCapsule\nCapsule()\n    .stroke(.blue, lineWidth: 2)   // stroke: 枠線のみ\n    .frame(width: 200, height: 50)\n\n// その他の基本シェイプ\nCircle()                          // 円\nRectangle()                       // 長方形\nRoundedRectangle(cornerRadius: 10) // 角丸長方形\nEllipse()                         // 楕円",
					"keywords": [
						"capsule",
						"shape",
						"pill",
						"circle",
						"rectangle",
						"rounded",
						"カプセル",
						"シェイプ",
						"形状",
						"角丸",
						"丸",
						"タグ"
					]
				},
				{
					"title": "Spacer & Divider - 余白と区切り",
					"code": "// Spacer: 利用可能な空間を埋める\nHStack {\n    Text(\"左端\")\n    Spacer() // ここが広がる\n    Text(\"右端\")\n}\n\n// Divider: 区切り線を表示\nVStack {\n    Text(\"上段\")\n    Divider()\n    Text(\"下段\")\n}",
					"keywords": ["space", "line", "separator", "gap", "fill", "余白", "区切り", "スペース"]
				}
			]
		},
		{
			"id": "data",
			"title": "データ表示と入力",
			"description": "データのリスト表示やユーザー入力を受け付けるコンポーネントです。",
			"codeBlocks": [
				{
					"title": "List - リスト表示",
					"code": "// 1. 配列からの動的生成（単純なデータ）\nlet items = [\"Apple\", \"Banana\", \"Orange\"]\n\n// id: \\.self の解説\n// 文字列や数値など、一意のIDを持たない単純な型の配列を表示する場合、\n// 「要素そのもの('\\.self')」を識別子として使います。\nList(items, id: \\.self) { item in\n    Text(item)\n}\n\n// 2. 構造体のリスト（推奨）\nstruct Fruit: Identifiable {\n    let id = UUID()     // 一意のID\n    let name: String\n}\n\nlet fruits = [\n    Fruit(name: \"Apple\"),\n    Fruit(name: \"Banana\")\n]\n\n// Identifiableに準拠していれば id指定は不要\nList(fruits) { fruit in\n    Text(fruit.name)\n}\n\n// 3. 削除機能付きのリスト\n// .onDelete を使うことでスワイプ削除が可能になります\nList {\n    ForEach(items, id: \\.self) { item in\n        Text(item)\n    }\n    .onDelete { indexSet in\n        items.remove(atOffsets: indexSet)\n    }\n}\n\n// 4. 静的なリスト\nList {\n    Text(\"設定\")\n    Text(\"プロフィール\")\n}",
					"keywords": [
						"table",
						"row",
						"collection",
						"array",
						"display",
						"リスト",
						"一覧",
						"テーブル"
					]
				},
				{
					"title": "TextField - テキスト入力",
					"code": "@State var name = \"\"\n\n// 基本的な入力フィールド\nTextField(\"名前を入力\", text: $name)\n    .textFieldStyle(.roundedBorder)\n\n// パスワード入力（伏せ字）\nSecureField(\"パスワード\", text: $password)\n\n// 数値入力キーボード指定\nTextField(\"年齢\", value: $age, format: .number)\n    .keyboardType(.numberPad)",
					"keywords": ["input", "form", "keyboard", "text", "entry", "入力", "テキストフィールド"]
				},
				{
					"title": "Picker - 選択肢から選ぶ",
					"code": "@State var selection = \"apple\"\nlet fruits = [\"apple\", \"banana\", \"orange\"]\n\n// 基本的なPicker\nPicker(\"フルーツを選択\", selection: $selection) {\n    ForEach(fruits, id: \\.self) { fruit in\n        Text(fruit)\n    }\n}\n\n// label: パラメータについて\n// Pickerの第一引数「label:」はアクセシビリティや\n// Form内での表示ラベルとして使われます。\n// 多くのスタイルでは画面上に表示されませんが、\n// VoiceOverなどの支援技術で読み上げられるため\n// 省略せず適切な説明を設定しましょう。\n\n// スタイルのバリエーション\n.pickerStyle(.segmented)  // セグメント（横並びボタン）\n.pickerStyle(.wheel)      // ホイール（iOS標準）\n.pickerStyle(.menu)       // ドロップダウンメニュー\n.pickerStyle(.inline)     // インライン（List内で展開）",
					"keywords": [
						"picker",
						"select",
						"dropdown",
						"option",
						"choice",
						"segmented",
						"選択",
						"ピッカー",
						"ドロップダウン"
					]
				},
				{
					"title": "ScrollView - スクロール",
					"code": "// 垂直スクロール\nScrollView {\n    VStack {\n        ForEach(0..<20) { i in\n            Text(\"行 \\(i)\")\n                .frame(maxWidth: .infinity)\n                .padding()\n                .background(.gray.opacity(0.1))\n        }\n    }\n}\n\n// 水平スクロール\nScrollView(.horizontal, showsIndicators: false) {\n    HStack {\n        // ...コンテンツ\n    }\n}",
					"keywords": ["scroll", "overflow", "content", "pan", "スクロール", "スクロールビュー"]
				}
			]
		},
		{
			"id": "swiftui-foreach",
			"title": "ForEach（リスト構築）",
			"description": "複数のビューを効率よく生成するSwiftUIコンポーネントです。",
			"codeBlocks": [
				{
					"title": "ForEachの基本的な使い方",
					"code": "import SwiftUI\n\n// ForEachは配列の各要素に対して、ビューを繰り返し生成します\n\nstruct FruitListView: View {\n    // 果物の名前の配列\n    let fruits = [\"りんご\", \"バナナ\", \"オレンジ\"]\n    \n    var body: some View {\n        VStack {\n            // ForEachを使ってリストアイテムを生成\n            ForEach(fruits, id: \\.self) { fruit in\n                Text(fruit)  // 各果物の名前をTextで表示\n                    .font(.headline)\n                    .padding()\n            }\n        }\n    }\n}\n\n// ForEachの要素:\n// - fruits: 繰り返す配列\n// - id: \\.self: 各要素を識別するキー（ここでは値そのものをID として使用）\n// - fruit in: クロージャで各要素を受け取る\n// - { 処理 }: 各要素に対して実行するビューの定義",
					"output": "（同じリストアイテムが3行に分かれて表示される）",
					"executable": false,
					"keywords": [
						"foreach",
						"list",
						"iterate",
						"loop",
						"array",
						"ビュー生成",
						"ループ",
						"繰り返し"
					]
				},
				{
					"title": "id パラメータの役割",
					"code": "import SwiftUI\n\n// idパラメータは、各要素を一意に識別するための「キー」です\n// SwiftUIが「どの要素が変更されたか」を判定するために使われます\n\n// パターン1: 値型（String, Int）の場合はid: \\.self を使う\nstruct SimpleView: View {\n    let numbers = [1, 2, 3, 4, 5]\n    \n    var body: some View {\n        VStack {\n            ForEach(numbers, id: \\.self) { num in\n                Text(\"数字: \\(num)\")\n            }\n        }\n    }\n}\n\n// パターン2: 複雑な型（構造体）の場合は、Identifiable に準拠させる\nstruct Student: Identifiable {\n    let id = UUID()  // 各学生に一意なIDを付与\n    var name: String\n    var grade: Int\n}\n\nstruct StudentListView: View {\n    let students = [\n        Student(name: \"太郎\", grade: 1),\n        Student(name: \"花子\", grade: 1),\n        Student(name: \"次郎\", grade: 2)\n    ]\n    \n    var body: some View {\n        VStack {\n            // Identifiableに準拠しているので、idを省略できる\n            ForEach(students) { student in\n                HStack {\n                    Text(student.name)\n                    Text(\"\\(student.grade)年\")\n                        .foregroundStyle(.secondary)\n                }\n                .padding()\n            }\n        }\n    }\n}\n\n// パターン3: プロパティを明示的に指定\nstruct UserView: View {\n    let users = [\n        (id: 1, name: \"太郎\"),\n        (id: 2, name: \"花子\"),\n        (id: 3, name: \"次郎\")\n    ]\n    \n    var body: some View {\n        VStack {\n            ForEach(users, id: \\.id) { user in  // idプロパティをキーとして使用\n                Text(user.name)\n            }\n        }\n    }\n}",
					"output": "（各パターンで配列の要素がリストアイテムとして表示される）",
					"executable": false,
					"keywords": ["id", "key", "identifiable", "uuid", "識別子", "一意", "キー"]
				},
				{
					"title": "ForEachと@State の組み合わせ",
					"code": "import SwiftUI\n\n// ForEachで動的にリストを更新する例\n\nstruct TodoListView: View {\n    // Todoアイテムの構造体\n    struct TodoItem: Identifiable {\n        let id = UUID()\n        var title: String\n        var isCompleted: Bool = false\n    }\n    \n    // @Stateで状態を管理\n    @State private var todos: [TodoItem] = [\n        TodoItem(title: \"牛乳を買う\"),\n        TodoItem(title: \"数学の宿題\"),\n        TodoItem(title: \"部屋を片付ける\")\n    ]\n    \n    var body: some View {\n        VStack {\n            Text(\"やることリスト\")\n                .font(.title)\n            \n            // ForEachでリストの各要素をビューとして生成\n            ForEach($todos) { $todo in  // $をつけてBindingとして受け取る\n                HStack {\n                    // チェックボックスの役割\n                    Image(systemName: todo.isCompleted ? \"checkmark.circle.fill\" : \"circle\")\n                        .foregroundStyle(todo.isCompleted ? .green : .gray)\n                        .onTapGesture {\n                            todo.isCompleted.toggle()  // タップで完了状態を切り替え\n                        }\n                    \n                    Text(todo.title)\n                        .strikethrough(todo.isCompleted)  // 完了時は取り消し線を表示\n                    \n                    Spacer()  // スペースを挿入\n                }\n                .padding()\n            }\n            \n            Spacer()\n        }\n    }\n}\n\n// ポイント:\n// - $todosでBindingリストを取得\n// - ForEachの中で$todoでBinding値を受け取る\n// - Bindingを使うことで、子ビューでの変更が親の@Stateに反映される",
					"output": "（チェックマークをタップすると、アイテムが完了状態に切り替わる）",
					"executable": false,
					"keywords": ["dynamic", "update", "binding", "state", "todo", "list", "動的", "更新"]
				},
				{
					"title": "ForEachでList・ScrollViewと組み合わせ",
					"code": "import SwiftUI\n\n// List内でForEachを使う（最もよくあるパターン）\n\nstruct BookListView: View {\n    struct Book: Identifiable {\n        let id = UUID()\n        var title: String\n        var author: String\n        var year: Int\n    }\n    \n    let books = [\n        Book(title: \"吾輩は猫である\", author: \"夏目漱石\", year: 1905),\n        Book(title: \"羅生門\", author: \"芥川龍之介\", year: 1915),\n        Book(title: \"こころ\", author: \"夏目漱石\", year: 1914)\n    ]\n    \n    var body: some View {\n        VStack {\n            Text(\"古典文学\")\n                .font(.title2)\n            \n            // ListはForEachと相性が良い\n            List {\n                ForEach(books) { book in\n                    VStack(alignment: .leading, spacing: 4) {\n                        Text(book.title)\n                            .font(.headline)\n                        Text(book.author)\n                            .font(.caption)\n                            .foregroundStyle(.secondary)\n                        Text(\"\\(book.year)年\")\n                            .font(.caption2)\n                            .foregroundStyle(.secondary)\n                    }\n                    .padding(.vertical, 4)\n                }\n            }\n            .listStyle(.plain)\n        }\n    }\n}\n\n// ScrollViewと組み合わせ\nstruct ScrollableListView: View {\n    let items = Array(1...100).map { \"アイテム#\\($0)\" }\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: 10) {\n                ForEach(items, id: \\.self) { item in\n                    Text(item)\n                        .frame(maxWidth: .infinity, alignment: .leading)\n                        .padding()\n                        .background(Color(.systemGray6))\n                        .cornerRadius(8)\n                }\n            }\n            .padding()\n        }\n    }\n}",
					"output": "（リスト形式でアイテムが表示され、スクロール可能になる）",
					"executable": false,
					"keywords": [
						"list",
						"scrollview",
						"container",
						"grid",
						"layout",
						"リスト表示",
						"スクロール"
					]
				},
				{
					"title": "ForEachのベストプラクティス",
					"code": "import SwiftUI\n\n// よくある間違いと正しい使い方\n\n// ❌ 間違い: idを指定しない（警告が出る）\n// ForEach(items) { item in ... }  // 危険\n\n// ✅ 正しい: 適切なidを指定\nstruct GoodPracticeView: View {\n    struct Task: Identifiable {\n        let id: UUID\n        var name: String\n        var done: Bool\n    }\n    \n    @State private var tasks: [Task] = [\n        Task(id: UUID(), name: \"タスク1\", done: false),\n        Task(id: UUID(), name: \"タスク2\", done: true)\n    ]\n    \n    var body: some View {\n        VStack {\n            // ✅ Good: Identifiableに準拠しているので安全\n            ForEach(tasks) { task in\n                Text(task.name)\n            }\n            \n            // ✅ Good: id: \\.self で値を識別\n            ForEach([\"A\", \"B\", \"C\"], id: \\.self) { letter in\n                Text(letter)\n            }\n            \n            // ✅ Good: id: \\.id でプロパティを指定\n            ForEach(tasks, id: \\.id) { task in\n                Text(task.name)\n            }\n        }\n    }\n}\n\n// ベストプラクティス:\n// 1. 可能なら Identifiable に準拠させる（最も安全）\n// 2. UUIDやデータベースのidを使う（重複がない）\n// 3. 値型の場合は id: \\.self を使う\n// 4. idを明示的に指定して意図を明確にする",
					"output": "（各パターンが正しく機能する）",
					"executable": false,
					"keywords": [
						"best practice",
						"safe",
						"identifiable",
						"uuid",
						"pattern",
						"ベストプラクティス",
						"安全"
					]
				}
			]
		},
		{
			"id": "navigation",
			"title": "ナビゲーション",
			"description": "画面間の遷移や階層的なナビゲーションを管理するためのコンポーネントです。",
			"codeBlocks": [
				{
					"title": "NavigationStack - 画面遷移",
					"code": "// 1. 基本的なビューの遷移\nNavigationStack {\n    VStack {\n        // NavigationLinkを使って遷移先を指定\n        NavigationLink(\"詳細画面へ\") {\n            Text(\"詳細画面\")\n                .navigationTitle(\"詳細\")\n        }\n    }\n    .navigationTitle(\"ホーム\")\n}\n\n// 2. リストを使った画面遷移\nNavigationStack {\n    List(1...5, id: \\\\.self) { index in\n        NavigationLink(\"アイテム \\\\(index)の詳細\") {\n            Text(\"アイテム \\\\(index)の詳細画面\")\n        }\n    }\n    .navigationTitle(\"アイテム一覧\")\n}\n\n// 3. 値ベースのプログラムによる遷移\n// enumなどで遷移先を管理すると便利です\nenum Route: Hashable {\n    case detail(String)\n    case settings\n}\n\n@State private var path = NavigationPath()\n\nNavigationStack(path: $path) {\n    VStack(spacing: 20) {\n        // 値を渡して遷移\n        NavigationLink(\"設定を開く\", value: Route.settings)\n        \n        // ボタンタップでプログラムから遷移を追加\n        Button(\"アイテムを見る\") {\n            path.append(Route.detail(\"あいうえお\"))\n        }\n    }\n    // 渡された値に応じて遷移先ビューを決定する\n    .navigationDestination(for: Route.self) { route in\n        switch route {\n        case .detail(let text):\n            Text(\"詳細: \\\\(text)\")\n        case .settings:\n            Text(\"設定画面\")\n        }\n    }\n    .navigationTitle(\"アプリのルート\")\n}",
					"keywords": [
						"navigation",
						"link",
						"stack",
						"path",
						"route",
						"遷移",
						"画面移動",
						"ナビゲーション",
						"リンク",
						"スタック"
					]
				}
			]
		}
	]
}
